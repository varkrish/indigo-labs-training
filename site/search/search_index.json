{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Modern Software Development Practices \u00b6 Overview \u00b6 Welcome to this comprehensive guide on modern software development practices, specifically designed for junior and mid-senior developers working with .NET and React Native applications . This documentation provides practical, actionable guidance for adopting cloud-native and agile methodologies using Podman/podman compose  and Red Hat UBI (Universal Base Images) . \ud83c\udfaf Target Audience \u00b6 Junior developers (0-3 years experience) learning modern development practices Mid-senior developers (3-7 years experience) adopting cloud-native and agile methodologies Primary technologies : .NET (C#) and React Native Containerization : Podman and podman compose  Base images : Red Hat UBI images exclusively \ud83d\udcda Documentation Structure \u00b6 This guide is organized into seven main sections, each building upon the previous ones: 1. Cloud Fundamentals \u00b6 Understanding cloud-native concepts, hybrid cloud strategies, and the CNCF landscape that forms the foundation of modern software development. 2. Containerization \u00b6 Deep dive into container fundamentals using Podman, CRI-O container engine, and Kubernetes/OpenShift orchestration platforms. 3. Development Foundations \u00b6 Core development practices including requirement-centric development, 12-factor app methodology, microservices architecture, and developer workflow practices. 4. Agile Development & Testing \u00b6 Comprehensive coverage of clean architecture, BDD/TDD practices, local development with podman compose , API mocking, secure coding, and performance testing. 5. CI/CD \u00b6 Cloud-native continuous integration and deployment practices that integrate with the entire development lifecycle. 6. Observability \u00b6 Monitoring and observability practices with focus on .NET OpenTelemetry implementation. 7. Red Hat Ecosystem \u00b6 Understanding Red Hat Software Collections and UBI images for secure, enterprise-grade container development. \ud83d\ude80 Getting Started \u00b6 Start with Cloud Fundamentals if you're new to cloud-native development Jump to Containerization if you need to understand Podman and container basics Explore Development Foundations for architectural and methodological guidance Dive into Testing for practical testing strategies and implementation Review CI/CD for automation and deployment practices Implement Observability for monitoring and troubleshooting Leverage Red Hat Ecosystem for enterprise-grade solutions \ud83d\udca1 Key Features \u00b6 Practical Examples : All code examples use .NET and React Native with Podman/UBI Progressive Learning : Content starts simple and builds complexity gradually Hands-on Exercises : Each section includes practical exercises to reinforce learning Real-world Scenarios : Examples relate to actual development challenges Security-first : Demonstrates secure coding practices throughout Open Source Focus : Emphasizes open-source tools and Red Hat technologies \ud83d\udd27 Prerequisites \u00b6 Before diving into this documentation, ensure you have: Basic understanding of software development concepts Familiarity with either .NET or React Native (or willingness to learn) Access to a development environment where you can install Podman Basic command-line experience \ud83d\udcd6 How to Use This Guide \u00b6 Each documentation page follows a consistent structure: - Overview and key concepts - Prerequisites and setup requirements - Practical examples with step-by-step instructions - Common pitfalls and how to avoid them - Best practices for team collaboration - Hands-on exercises to practice concepts - Additional resources for deeper learning Navigate through the sections using the sidebar navigation, and don't hesitate to jump between topics as your projects require different knowledge areas. This documentation is continuously updated to reflect the latest best practices in modern software development. All examples are tested and verified to work with the specified tools and versions.","title":"Home"},{"location":"#modern-software-development-practices","text":"","title":"Modern Software Development Practices"},{"location":"#overview","text":"Welcome to this comprehensive guide on modern software development practices, specifically designed for junior and mid-senior developers working with .NET and React Native applications . This documentation provides practical, actionable guidance for adopting cloud-native and agile methodologies using Podman/podman compose  and Red Hat UBI (Universal Base Images) .","title":"Overview"},{"location":"#target-audience","text":"Junior developers (0-3 years experience) learning modern development practices Mid-senior developers (3-7 years experience) adopting cloud-native and agile methodologies Primary technologies : .NET (C#) and React Native Containerization : Podman and podman compose  Base images : Red Hat UBI images exclusively","title":"\ud83c\udfaf Target Audience"},{"location":"#documentation-structure","text":"This guide is organized into seven main sections, each building upon the previous ones:","title":"\ud83d\udcda Documentation Structure"},{"location":"#1-cloud-fundamentals","text":"Understanding cloud-native concepts, hybrid cloud strategies, and the CNCF landscape that forms the foundation of modern software development.","title":"1. Cloud Fundamentals"},{"location":"#2-containerization","text":"Deep dive into container fundamentals using Podman, CRI-O container engine, and Kubernetes/OpenShift orchestration platforms.","title":"2. Containerization"},{"location":"#3-development-foundations","text":"Core development practices including requirement-centric development, 12-factor app methodology, microservices architecture, and developer workflow practices.","title":"3. Development Foundations"},{"location":"#4-agile-development-testing","text":"Comprehensive coverage of clean architecture, BDD/TDD practices, local development with podman compose , API mocking, secure coding, and performance testing.","title":"4. Agile Development &amp; Testing"},{"location":"#5-cicd","text":"Cloud-native continuous integration and deployment practices that integrate with the entire development lifecycle.","title":"5. CI/CD"},{"location":"#6-observability","text":"Monitoring and observability practices with focus on .NET OpenTelemetry implementation.","title":"6. Observability"},{"location":"#7-red-hat-ecosystem","text":"Understanding Red Hat Software Collections and UBI images for secure, enterprise-grade container development.","title":"7. Red Hat Ecosystem"},{"location":"#getting-started","text":"Start with Cloud Fundamentals if you're new to cloud-native development Jump to Containerization if you need to understand Podman and container basics Explore Development Foundations for architectural and methodological guidance Dive into Testing for practical testing strategies and implementation Review CI/CD for automation and deployment practices Implement Observability for monitoring and troubleshooting Leverage Red Hat Ecosystem for enterprise-grade solutions","title":"\ud83d\ude80 Getting Started"},{"location":"#key-features","text":"Practical Examples : All code examples use .NET and React Native with Podman/UBI Progressive Learning : Content starts simple and builds complexity gradually Hands-on Exercises : Each section includes practical exercises to reinforce learning Real-world Scenarios : Examples relate to actual development challenges Security-first : Demonstrates secure coding practices throughout Open Source Focus : Emphasizes open-source tools and Red Hat technologies","title":"\ud83d\udca1 Key Features"},{"location":"#prerequisites","text":"Before diving into this documentation, ensure you have: Basic understanding of software development concepts Familiarity with either .NET or React Native (or willingness to learn) Access to a development environment where you can install Podman Basic command-line experience","title":"\ud83d\udd27 Prerequisites"},{"location":"#how-to-use-this-guide","text":"Each documentation page follows a consistent structure: - Overview and key concepts - Prerequisites and setup requirements - Practical examples with step-by-step instructions - Common pitfalls and how to avoid them - Best practices for team collaboration - Hands-on exercises to practice concepts - Additional resources for deeper learning Navigate through the sections using the sidebar navigation, and don't hesitate to jump between topics as your projects require different knowledge areas. This documentation is continuously updated to reflect the latest best practices in modern software development. All examples are tested and verified to work with the specified tools and versions.","title":"\ud83d\udcd6 How to Use This Guide"},{"location":"1_cloud/cloud_native_development/","text":"Cloud Native Development \u00b6 Overview \u00b6 Cloud native development represents a fundamental shift in how we build, deploy, and manage applications. It's an approach that fully embraces the cloud computing model, designing applications specifically to run in and take advantage of distributed, dynamic cloud environments. For junior and mid-senior developers working with .NET and React Native applications, understanding cloud native principles is essential for building scalable, resilient, and maintainable modern applications. Cloud native development goes beyond simply moving applications to the cloud\u2014it involves architecting applications as collections of loosely coupled services, using containers for packaging, and leveraging cloud platforms for orchestration, scaling, and management. Key Concepts \u00b6 The Four Pillars of Cloud Native \u00b6 Microservices Architecture : Applications built as independent, loosely coupled services Containerization : Applications packaged in lightweight, portable containers DevOps and CI/CD : Automated build, test, and deployment pipelines Dynamic Orchestration : Container orchestration and service mesh technologies Cloud Native Characteristics \u00b6 Scalability : Applications can scale horizontally across distributed infrastructure Resilience : Built-in fault tolerance and recovery mechanisms Observability : Comprehensive monitoring, logging, and tracing capabilities Automation : Infrastructure and deployment automation Portability : Applications run consistently across different cloud environments Cloud Native vs Traditional Development \u00b6 Aspect Traditional Cloud Native Architecture Monolithic Microservices Deployment Manual/Scripted Automated CI/CD Scaling Vertical Horizontal Infrastructure Static/Physical Dynamic/Virtual State Management Stateful Stateless preferred Communication Direct calls API-first Prerequisites \u00b6 Understanding of distributed systems concepts Familiarity with .NET Core/6+ and React Native Basic knowledge of containers and Podman Understanding of RESTful APIs and HTTP protocols Experience with version control (Git) and collaborative development Required Tools and Technologies \u00b6 Podman for containerization Red Hat UBI base images .NET 6+ for backend services React Native for mobile applications OpenShift or Kubernetes for orchestration Git for source control Practical Examples \u00b6 Example 1: Cloud Native .NET Microservice \u00b6 Let's build a cloud native order service that demonstrates key principles. Step 1: Design the Service Architecture \u00b6 // OrderService/Models/Order.cs using System.ComponentModel.DataAnnotations ; namespace OrderService.Models { public class Order { public Guid Id { get ; set ; } = Guid . NewGuid (); [Required] public string CustomerId { get ; set ; } = string . Empty ; public List < OrderItem > Items { get ; set ; } = new (); public decimal TotalAmount => Items . Sum ( i => i . Price * i . Quantity ); public OrderStatus Status { get ; set ; } = OrderStatus . Pending ; public DateTime CreatedAt { get ; set ; } = DateTime . UtcNow ; public DateTime ? UpdatedAt { get ; set ; } } public class OrderItem { public Guid Id { get ; set ; } = Guid . NewGuid (); [Required] public string ProductId { get ; set ; } = string . Empty ; [Required] public string ProductName { get ; set ; } = string . Empty ; [Range(0.01, double.MaxValue)] public decimal Price { get ; set ; } [Range(1, int.MaxValue)] public int Quantity { get ; set ; } } public enum OrderStatus { Pending , Confirmed , Processing , Shipped , Delivered , Cancelled } } Step 2: Implement Cloud Native Patterns \u00b6 // OrderService/Controllers/OrdersController.cs using Microsoft.AspNetCore.Mvc ; using OrderService.Models ; using OrderService.Services ; namespace OrderService.Controllers { [ApiController] [Route(\"api/v1/[controller] \")] public class OrdersController : ControllerBase { private readonly IOrderService _orderService ; private readonly ILogger < OrdersController > _logger ; private readonly IConfiguration _configuration ; public OrdersController ( IOrderService orderService , ILogger < OrdersController > logger , IConfiguration configuration ) { _orderService = orderService ; _logger = logger ; _configuration = configuration ; } [HttpGet(\"health\")] public IActionResult HealthCheck () { return Ok ( new { status = \"healthy\" , timestamp = DateTime . UtcNow , version = _configuration [ \"App:Version\" ], environment = Environment . GetEnvironmentVariable ( \"ASPNETCORE_ENVIRONMENT\" ) }); } [HttpGet] public async Task < ActionResult < IEnumerable < Order >>> GetOrders ( [FromQuery] string? customerId = null , [FromQuery] int page = 1 , [FromQuery] int pageSize = 10 ) { try { _logger . LogInformation ( \"Retrieving orders for customer: {CustomerId}, Page: {Page}\" , customerId ?? \"all\" , page ); var orders = await _orderService . GetOrdersAsync ( customerId , page , pageSize ); Response . Headers . Add ( \"X-Total-Count\" , orders . TotalCount . ToString ()); Response . Headers . Add ( \"X-Page\" , page . ToString ()); Response . Headers . Add ( \"X-Page-Size\" , pageSize . ToString ()); return Ok ( orders . Items ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error retrieving orders\" ); return StatusCode ( 500 , new { error = \"Internal server error\" , traceId = Activity . Current ?. Id }); } } [HttpPost] public async Task < ActionResult < Order >> CreateOrder ([ FromBody ] CreateOrderRequest request ) { try { if ( ! ModelState . IsValid ) { return BadRequest ( ModelState ); } _logger . LogInformation ( \"Creating order for customer: {CustomerId}\" , request . CustomerId ); var order = await _orderService . CreateOrderAsync ( request ); // Publish domain event for other services await _orderService . PublishOrderCreatedEventAsync ( order ); return CreatedAtAction ( nameof ( GetOrderById ), new { id = order . Id }, order ); } catch ( BusinessValidationException ex ) { _logger . LogWarning ( ex , \"Business validation error creating order\" ); return BadRequest ( new { error = ex . Message }); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error creating order\" ); return StatusCode ( 500 , new { error = \"Internal server error\" , traceId = Activity . Current ?. Id }); } } [HttpGet(\"{id}\")] public async Task < ActionResult < Order >> GetOrderById ( Guid id ) { try { var order = await _orderService . GetOrderByIdAsync ( id ); if ( order == null ) { return NotFound ( new { error = $\"Order {id} not found\" }); } return Ok ( order ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error retrieving order {OrderId}\" , id ); return StatusCode ( 500 , new { error = \"Internal server error\" , traceId = Activity . Current ?. Id }); } } [HttpPut(\"{id}/status\")] public async Task < ActionResult < Order >> UpdateOrderStatus ( Guid id , [FromBody] UpdateOrderStatusRequest request ) { try { var order = await _orderService . UpdateOrderStatusAsync ( id , request . Status ); if ( order == null ) { return NotFound ( new { error = $\"Order {id} not found\" }); } // Publish status change event await _orderService . PublishOrderStatusChangedEventAsync ( order ); return Ok ( order ); } catch ( BusinessValidationException ex ) { _logger . LogWarning ( ex , \"Business validation error updating order status\" ); return BadRequest ( new { error = ex . Message }); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error updating order status for {OrderId}\" , id ); return StatusCode ( 500 , new { error = \"Internal server error\" , traceId = Activity . Current ?. Id }); } } } } Step 3: Implement Configuration and Resilience \u00b6 // OrderService/Services/OrderService.cs using OrderService.Models ; using OrderService.Data ; using Microsoft.Extensions.Options ; using Polly ; using Polly.Extensions.Http ; namespace OrderService.Services { public interface IOrderService { Task < PagedResult < Order >> GetOrdersAsync ( string? customerId , int page , int pageSize ); Task < Order ?> GetOrderByIdAsync ( Guid id ); Task < Order > CreateOrderAsync ( CreateOrderRequest request ); Task < Order ?> UpdateOrderStatusAsync ( Guid id , OrderStatus status ); Task PublishOrderCreatedEventAsync ( Order order ); Task PublishOrderStatusChangedEventAsync ( Order order ); } public class OrderService : IOrderService { private readonly IOrderRepository _orderRepository ; private readonly ICustomerService _customerService ; private readonly IProductService _productService ; private readonly IEventPublisher _eventPublisher ; private readonly ILogger < OrderService > _logger ; private readonly OrderServiceOptions _options ; private readonly HttpClient _httpClient ; public OrderService ( IOrderRepository orderRepository , ICustomerService customerService , IProductService productService , IEventPublisher eventPublisher , ILogger < OrderService > logger , IOptions < OrderServiceOptions > options , HttpClient httpClient ) { _orderRepository = orderRepository ; _customerService = customerService ; _productService = productService ; _eventPublisher = eventPublisher ; _logger = logger ; _options = options . Value ; _httpClient = httpClient ; } public async Task < Order > CreateOrderAsync ( CreateOrderRequest request ) { // Validate customer exists var customer = await _customerService . GetCustomerAsync ( request . CustomerId ); if ( customer == null ) { throw new BusinessValidationException ( $\"Customer {request.CustomerId} not found\" ); } // Validate products and get current prices var validatedItems = new List < OrderItem > (); foreach ( var item in request . Items ) { var product = await _productService . GetProductAsync ( item . ProductId ); if ( product == null ) { throw new BusinessValidationException ( $\"Product {item.ProductId} not found\" ); } if ( product . StockQuantity < item . Quantity ) { throw new BusinessValidationException ( $\"Insufficient stock for product {product.Name}. Available: {product.StockQuantity}, Requested: {item.Quantity}\" ); } validatedItems . Add ( new OrderItem { ProductId = item . ProductId , ProductName = product . Name , Price = product . Price , // Use current price Quantity = item . Quantity }); } var order = new Order { CustomerId = request . CustomerId , Items = validatedItems , Status = OrderStatus . Pending }; // Reserve inventory await _productService . ReserveInventoryAsync ( order . Items ); // Save order await _orderRepository . CreateAsync ( order ); _logger . LogInformation ( \"Order {OrderId} created for customer {CustomerId} with total {Total:C}\" , order . Id , order . CustomerId , order . TotalAmount ); return order ; } public async Task PublishOrderCreatedEventAsync ( Order order ) { var eventData = new OrderCreatedEvent { OrderId = order . Id , CustomerId = order . CustomerId , TotalAmount = order . TotalAmount , Items = order . Items . Select ( i => new OrderItemEvent { ProductId = i . ProductId , Quantity = i . Quantity , Price = i . Price }). ToList (), CreatedAt = order . CreatedAt }; await _eventPublisher . PublishAsync ( \"order.created\" , eventData ); } // Additional resilience patterns public async Task < Product ?> GetProductWithRetryAsync ( string productId ) { var retryPolicy = Policy . Handle < HttpRequestException > () . Or < TaskCanceledException > () . WaitAndRetryAsync ( retryCount : 3 , sleepDurationProvider : retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( 2 , retryAttempt )), onRetry : ( outcome , timespan , retryCount , context ) => { _logger . LogWarning ( \"Retry {RetryCount} for product service call after {Delay}ms\" , retryCount , timespan . TotalMilliseconds ); }); return await retryPolicy . ExecuteAsync ( async () => { var response = await _httpClient . GetAsync ( $\"/api/products/{productId}\" ); response . EnsureSuccessStatusCode (); return await response . Content . ReadFromJsonAsync < Product > (); }); } } } Step 4: Create Cloud Native Containerfile \u00b6 # Use Red Hat UBI .NET 6 multi-stage build FROM registry.access.redhat.com/ubi8/dotnet-60 AS build # Set working directory WORKDIR /src # Copy project files and restore dependencies COPY [ \"OrderService/OrderService.csproj\" , \"OrderService/\" ] RUN dotnet restore \"OrderService/OrderService.csproj\" # Copy source code and build COPY . . WORKDIR \"/src/OrderService\" RUN dotnet build \"OrderService.csproj\" -c Release -o /app/build # Publish the application FROM build AS publish RUN dotnet publish \"OrderService.csproj\" -c Release -o /app/publish /p:UseAppHost = false # Create runtime image FROM registry.access.redhat.com/ubi8/dotnet-60-runtime AS runtime # Create non-root user for security RUN groupadd -r appuser && useradd -r -g appuser appuser # Set working directory and copy published app WORKDIR /app COPY --from = publish --chown = appuser:appuser /app/publish . # Install curl for health checks USER root RUN dnf update -y && dnf install -y curl && dnf clean all USER appuser # Configure application ENV ASPNETCORE_URLS = http://+:8080 ENV ASPNETCORE_ENVIRONMENT = Production EXPOSE 8080 # Add health check HEALTHCHECK --interval = 30s --timeout = 3s --start-period = 5s --retries = 3 \\ CMD curl -f http://localhost:8080/api/v1/orders/health || exit 1 # Set entrypoint ENTRYPOINT [ \"dotnet\" , \"OrderService.dll\" ] Example 2: Cloud Native React Native Application \u00b6 Create a mobile app that consumes cloud native microservices. Step 1: Implement API Client with Resilience \u00b6 // src/services/ApiClient.ts import axios , { AxiosInstance , AxiosRequestConfig , AxiosResponse } from 'axios' ; import AsyncStorage from '@react-native-async-storage/async-storage' ; export interface ApiConfig { baseURL : string ; timeout : number ; maxRetries : number ; retryDelay : number ; } export class ApiClient { private client : AxiosInstance ; private config : ApiConfig ; constructor ( config : ApiConfig ) { this . config = config ; this . client = axios . create ({ baseURL : config.baseURL , timeout : config.timeout , headers : { 'Content-Type' : 'application/json' , 'Accept' : 'application/json' , }, }); this . setupInterceptors (); } private setupInterceptors () : void { // Request interceptor for authentication this . client . interceptors . request . use ( async ( config ) => { const token = await AsyncStorage . getItem ( 'authToken' ); if ( token ) { config . headers . Authorization = `Bearer ${ token } ` ; } // Add correlation ID for distributed tracing config . headers [ 'X-Correlation-ID' ] = this . generateCorrelationId (); console . log ( `\ud83d\ude80 API Request: ${ config . method ? . toUpperCase () } ${ config . url } ` ); return config ; }, ( error ) => { console . error ( '\u274c Request interceptor error:' , error ); return Promise . reject ( error ); } ); // Response interceptor for error handling and retry logic this . client . interceptors . response . use ( ( response ) => { console . log ( `\u2705 API Response: ${ response . status } ${ response . config . url } ` ); return response ; }, async ( error ) => { const originalRequest = error . config ; if ( error . response ? . status === 401 && ! originalRequest . _retry ) { originalRequest . _retry = true ; await this . handleUnauthorized (); return this . client ( originalRequest ); } if ( this . shouldRetry ( error ) && ! originalRequest . _retryCount ) { return this . retryRequest ( originalRequest ); } console . error ( '\u274c API Error:' , error . response ? . data || error . message ); return Promise . reject ( this . normalizeError ( error )); } ); } private shouldRetry ( error : any ) : boolean { return ( error . code === 'NETWORK_ERROR' || error . code === 'TIMEOUT' || ( error . response && error . response . status >= 500 ) ); } private async retryRequest ( originalRequest : any ) : Promise < AxiosResponse > { originalRequest . _retryCount = ( originalRequest . _retryCount || 0 ) + 1 ; if ( originalRequest . _retryCount > this . config . maxRetries ) { throw new Error ( `Max retries ( ${ this . config . maxRetries } ) exceeded` ); } const delay = this . config . retryDelay * Math . pow ( 2 , originalRequest . _retryCount - 1 ); console . log ( `\ud83d\udd04 Retrying request ${ originalRequest . _retryCount } / ${ this . config . maxRetries } after ${ delay } ms` ); await new Promise ( resolve => setTimeout ( resolve , delay )); return this . client ( originalRequest ); } private async handleUnauthorized () : Promise < void > { await AsyncStorage . removeItem ( 'authToken' ); await AsyncStorage . removeItem ( 'refreshToken' ); // Navigate to login screen // NavigationService.navigate('Login'); } private normalizeError ( error : any ) : ApiError { return { message : error.response?.data?.error || error . message || 'An unexpected error occurred' , status : error.response?.status , traceId : error.response?.data?.traceId , correlationId : error.config?.headers [ 'X-Correlation-ID' ], }; } private generateCorrelationId () : string { return `mobile- ${ Date . now () } - ${ Math . random (). toString ( 36 ). substr ( 2 , 9 ) } ` ; } // Public API methods public async get < T > ( url : string , config? : AxiosRequestConfig ) : Promise < T > { const response = await this . client . get < T > ( url , config ); return response . data ; } public async post < T > ( url : string , data? : any , config? : AxiosRequestConfig ) : Promise < T > { const response = await this . client . post < T > ( url , data , config ); return response . data ; } public async put < T > ( url : string , data? : any , config? : AxiosRequestConfig ) : Promise < T > { const response = await this . client . put < T > ( url , data , config ); return response . data ; } public async delete < T > ( url : string , config? : AxiosRequestConfig ) : Promise < T > { const response = await this . client . delete < T > ( url , config ); return response . data ; } } export interface ApiError { message : string ; status? : number ; traceId? : string ; correlationId? : string ; } // Service factory export const createApiClient = ( environment : 'development' | 'staging' | 'production' ) : ApiClient => { const configs = { development : { baseURL : 'http://localhost:8080/api/v1' , timeout : 10000 , maxRetries : 2 , retryDelay : 1000 , }, staging : { baseURL : 'https://api-staging.example.com/api/v1' , timeout : 15000 , maxRetries : 3 , retryDelay : 1000 , }, production : { baseURL : 'https://api.example.com/api/v1' , timeout : 15000 , maxRetries : 3 , retryDelay : 1000 , }, }; return new ApiClient ( configs [ environment ]); }; Step 2: Implement Domain Services \u00b6 // src/services/OrderService.ts import { ApiClient , ApiError } from './ApiClient' ; export interface Order { id : string ; customerId : string ; items : OrderItem []; totalAmount : number ; status : OrderStatus ; createdAt : string ; updatedAt? : string ; } export interface OrderItem { id : string ; productId : string ; productName : string ; price : number ; quantity : number ; } export interface CreateOrderRequest { customerId : string ; items : CreateOrderItemRequest []; } export interface CreateOrderItemRequest { productId : string ; quantity : number ; } export enum OrderStatus { Pending = 'Pending' , Confirmed = 'Confirmed' , Processing = 'Processing' , Shipped = 'Shipped' , Delivered = 'Delivered' , Cancelled = 'Cancelled' , } export class OrderService { constructor ( private apiClient : ApiClient ) {} async getOrders ( customerId? : string , page : number = 1 , pageSize : number = 10 ) : Promise < Order [] > { try { const params = new URLSearchParams ({ page : page.toString (), pageSize : pageSize.toString (), }); if ( customerId ) { params . append ( 'customerId' , customerId ); } return await this . apiClient . get < Order [] > ( `/orders? ${ params . toString () } ` ); } catch ( error ) { console . error ( 'Failed to fetch orders:' , error ); throw this . handleServiceError ( error , 'Failed to load orders' ); } } async getOrderById ( orderId : string ) : Promise < Order > { try { return await this . apiClient . get < Order > ( `/orders/ ${ orderId } ` ); } catch ( error ) { console . error ( `Failed to fetch order ${ orderId } :` , error ); throw this . handleServiceError ( error , 'Failed to load order details' ); } } async createOrder ( request : CreateOrderRequest ) : Promise < Order > { try { return await this . apiClient . post < Order > ( '/orders' , request ); } catch ( error ) { console . error ( 'Failed to create order:' , error ); throw this . handleServiceError ( error , 'Failed to create order' ); } } async updateOrderStatus ( orderId : string , status : OrderStatus ) : Promise < Order > { try { return await this . apiClient . put < Order > ( `/orders/ ${ orderId } /status` , { status }); } catch ( error ) { console . error ( `Failed to update order ${ orderId } status:` , error ); throw this . handleServiceError ( error , 'Failed to update order status' ); } } private handleServiceError ( error : any , defaultMessage : string ) : ServiceError { if ( error . status === 404 ) { return new ServiceError ( 'Order not found' , 'NOT_FOUND' ); } if ( error . status === 400 ) { return new ServiceError ( error . message || 'Invalid request' , 'VALIDATION_ERROR' ); } if ( error . status >= 500 ) { return new ServiceError ( 'Service temporarily unavailable' , 'SERVER_ERROR' ); } return new ServiceError ( defaultMessage , 'UNKNOWN_ERROR' ); } } export class ServiceError extends Error { constructor ( message : string , public readonly code : string , public readonly originalError? : any ) { super ( message ); this . name = 'ServiceError' ; } } Example 3: podman compose  for Development \u00b6 Create a development environment that mirrors production: # compose.yml version : '3.8' services : # API Gateway / Load Balancer nginx : image : registry.access.redhat.com/ubi8/nginx-120 ports : - \"8080:8080\" volumes : - ./nginx/nginx.conf:/etc/nginx/nginx.conf:Z depends_on : - order-service - product-service - customer-service networks : - app-network # Order Service order-service : build : context : ./OrderService Containerfile : Containerfile.dev environment : - ASPNETCORE_ENVIRONMENT=Development - ConnectionStrings__DefaultConnection=Host=postgres;Database=orderdb;Username=orderuser;Password=orderpass - Services__CustomerService__BaseUrl=http://customer-service:8080 - Services__ProductService__BaseUrl=http://product-service:8080 - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 ports : - \"5001:8080\" depends_on : - postgres - rabbitmq volumes : - ./OrderService:/app:Z networks : - app-network # Product Service product-service : build : context : ./ProductService Containerfile : Containerfile.dev environment : - ASPNETCORE_ENVIRONMENT=Development - ConnectionStrings__DefaultConnection=Host=postgres;Database=productdb;Username=productuser;Password=productpass - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 ports : - \"5002:8080\" depends_on : - postgres - rabbitmq volumes : - ./ProductService:/app:Z networks : - app-network # Customer Service customer-service : build : context : ./CustomerService Containerfile : Containerfile.dev environment : - ASPNETCORE_ENVIRONMENT=Development - ConnectionStrings__DefaultConnection=Host=postgres;Database=customerdb;Username=customeruser;Password=customerpass ports : - \"5003:8080\" depends_on : - postgres volumes : - ./CustomerService:/app:Z networks : - app-network # PostgreSQL Database postgres : image : registry.access.redhat.com/rhel8/postgresql-13 environment : - POSTGRESQL_USER=postgres - POSTGRESQL_PASSWORD=postgres - POSTGRESQL_DATABASE=postgres ports : - \"5432:5432\" volumes : - postgres_data:/var/lib/pgsql/data - ./database/init-scripts:/docker-entrypoint-initdb.d:Z networks : - app-network # RabbitMQ for event-driven communication rabbitmq : image : registry.access.redhat.com/ubi8/ubi:latest command : | bash -c \" dnf install -y rabbitmq-server && systemctl enable rabbitmq-server && rabbitmq-server \" environment : - RABBITMQ_DEFAULT_USER=guest - RABBITMQ_DEFAULT_PASS=guest ports : - \"5672:5672\" - \"15672:15672\" volumes : - rabbitmq_data:/var/lib/rabbitmq networks : - app-network # Redis for caching redis : image : registry.access.redhat.com/rhel8/redis-6 ports : - \"6379:6379\" volumes : - redis_data:/var/lib/redis/data networks : - app-network # Monitoring and Observability prometheus : image : prom/prometheus:latest ports : - \"9090:9090\" volumes : - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:Z - prometheus_data:/prometheus networks : - app-network grafana : image : grafana/grafana:latest ports : - \"3000:3000\" environment : - GF_SECURITY_ADMIN_PASSWORD=admin volumes : - grafana_data:/var/lib/grafana - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:Z - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:Z networks : - app-network volumes : postgres_data : rabbitmq_data : redis_data : prometheus_data : grafana_data : networks : app-network : driver : bridge Common Pitfalls \u00b6 1. Monolithic Thinking in Microservices \u00b6 Problem : Creating \"distributed monoliths\" where services are too tightly coupled. Solution : Design services around business capabilities, not technical layers: // BAD: Technical layer separation public class UserController { /* All user operations */ } public class OrderController { /* All order operations */ } public class ProductController { /* All product operations */ } // GOOD: Business capability separation public class CustomerManagementService { /* Customer lifecycle */ } public class OrderProcessingService { /* Order workflow */ } public class InventoryManagementService { /* Stock management */ } 2. Ignoring Data Consistency \u00b6 Problem : Not properly handling distributed data consistency across services. Solution : Implement eventual consistency patterns and saga patterns: // Saga pattern implementation public class OrderProcessingSaga { public async Task ProcessOrderAsync ( Order order ) { var compensationActions = new List < Func < Task >> (); try { // Reserve inventory await _inventoryService . ReserveItemsAsync ( order . Items ); compensationActions . Add (() => _inventoryService . ReleaseReservationAsync ( order . Id )); // Process payment await _paymentService . ProcessPaymentAsync ( order . CustomerId , order . TotalAmount ); compensationActions . Add (() => _paymentService . RefundPaymentAsync ( order . Id )); // Confirm order await _orderService . ConfirmOrderAsync ( order . Id ); } catch ( Exception ex ) { // Execute compensation actions in reverse order compensationActions . Reverse (); foreach ( var action in compensationActions ) { try { await action (); } catch ( Exception compensationEx ) { _logger . LogError ( compensationEx , \"Compensation action failed\" ); } } throw ; } } } 3. Poor Service Communication \u00b6 Problem : Synchronous communication causing cascading failures. Solution : Use asynchronous messaging and circuit breaker patterns: public class ResilientServiceClient { private readonly IAsyncPolicy < HttpResponseMessage > _retryPolicy ; private readonly IAsyncPolicy < HttpResponseMessage > _circuitBreakerPolicy ; public ResilientServiceClient () { _retryPolicy = Policy . HandleResult < HttpResponseMessage > ( r => ! r . IsSuccessStatusCode ) . WaitAndRetryAsync ( 3 , retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( 2 , retryAttempt ))); _circuitBreakerPolicy = Policy . HandleResult < HttpResponseMessage > ( r => ! r . IsSuccessStatusCode ) . CircuitBreakerAsync ( 5 , TimeSpan . FromSeconds ( 30 )); } public async Task < T > GetAsync < T > ( string endpoint ) { var response = await _retryPolicy . WrapAsync ( _circuitBreakerPolicy ) . ExecuteAsync (() => _httpClient . GetAsync ( endpoint )); response . EnsureSuccessStatusCode (); return await response . Content . ReadFromJsonAsync < T > (); } } 4. Inadequate Observability \u00b6 Problem : Lack of proper monitoring, logging, and tracing in distributed systems. Solution : Implement comprehensive observability from the start: // Structured logging with correlation IDs public class OrderController : ControllerBase { public async Task < IActionResult > CreateOrder ([ FromBody ] CreateOrderRequest request ) { var correlationId = HttpContext . Items [ \"CorrelationId\" ] ?. ToString (); using var scope = _logger . BeginScope ( new Dictionary < string , object > { [\"CorrelationId\"] = correlationId , [\"Operation\"] = \"CreateOrder\" , [\"CustomerId\"] = request . CustomerId }); _logger . LogInformation ( \"Creating order for customer {CustomerId} with {ItemCount} items\" , request . CustomerId , request . Items . Count ); try { var order = await _orderService . CreateOrderAsync ( request ); _logger . LogInformation ( \"Order {OrderId} created successfully with total {Total:C}\" , order . Id , order . TotalAmount ); return CreatedAtAction ( nameof ( GetOrderById ), new { id = order . Id }, order ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Failed to create order for customer {CustomerId}\" , request . CustomerId ); throw ; } } } Best Practices \u00b6 1. Design for Failure \u00b6 Implement circuit breakers and retries Use bulkhead patterns to isolate failures Design graceful degradation strategies Implement health checks and readiness probes 2. Configuration Management \u00b6 // Environment-specific configuration public class ServiceConfiguration { public string ConnectionString { get ; set ; } public int TimeoutMs { get ; set ; } public int MaxRetries { get ; set ; } public bool EnableCircuitBreaker { get ; set ; } public static ServiceConfiguration FromEnvironment () { return new ServiceConfiguration { ConnectionString = Environment . GetEnvironmentVariable ( \"CONNECTION_STRING\" ) ?? throw new InvalidOperationException ( \"CONNECTION_STRING not configured\" ), TimeoutMs = int . Parse ( Environment . GetEnvironmentVariable ( \"TIMEOUT_MS\" ) ?? \"30000\" ), MaxRetries = int . Parse ( Environment . GetEnvironmentVariable ( \"MAX_RETRIES\" ) ?? \"3\" ), EnableCircuitBreaker = bool . Parse ( Environment . GetEnvironmentVariable ( \"ENABLE_CIRCUIT_BREAKER\" ) ?? \"true\" ) }; } } 3. API Versioning \u00b6 // API versioning strategy [ApiController] [ApiVersion(\"1.0\")] [ApiVersion(\"2.0\")] [Route(\"api/v{version:apiVersion}/[controller] \")] public class OrdersController : ControllerBase { [HttpGet] [MapToApiVersion(\"1.0\")] public async Task < ActionResult < IEnumerable < OrderV1 >>> GetOrdersV1 () { // Legacy implementation } [HttpGet] [MapToApiVersion(\"2.0\")] public async Task < ActionResult < PagedResult < OrderV2 >>> GetOrdersV2 ( [FromQuery] int page = 1 , [FromQuery] int pageSize = 10 ) { // Enhanced implementation with pagination } } 4. Security \u00b6 Use HTTPS everywhere Implement proper authentication and authorization Validate all inputs Use secrets management Scan containers for vulnerabilities Tools and Resources \u00b6 Development Tools \u00b6 Podman : Container runtime and management podman compose  : Multi-container application orchestration Visual Studio Code : IDE with container extensions Postman : API testing and documentation .NET CLI : Command-line development tools Monitoring and Observability \u00b6 Prometheus : Metrics collection Grafana : Metrics visualization Jaeger : Distributed tracing ELK Stack : Centralized logging Application Insights : APM for .NET Useful Resources \u00b6 Cloud Native Computing Foundation 12-Factor App Methodology Microservices Pattern Library Podman Documentation .NET Microservices Guide Hands-on Exercise \u00b6 Exercise: Build a Complete Cloud Native E-commerce Platform \u00b6 Create a full-featured e-commerce platform demonstrating cloud native principles. Requirements: Microservices Architecture: User management service Product catalog service Shopping cart service Order processing service Payment service Notification service Technology Stack: .NET 6+ for backend services React Native for mobile app PostgreSQL for data persistence Redis for caching RabbitMQ for event-driven communication Cloud Native Features: Containerized with Podman and UBI images Health checks and readiness probes Configuration externalization Distributed tracing and monitoring API gateway and service discovery Event-driven architecture Non-functional Requirements: Handle 1000 concurrent users 99.9% availability Sub-100ms API response times Comprehensive observability Security best practices Deliverables: Complete microservices implementation Mobile application with offline capabilities Deployment configuration for development and production Monitoring and alerting setup Performance testing results Security assessment report Comprehensive documentation Summary \u00b6 Cloud native development represents a fundamental shift in software architecture and development practices. Key takeaways include: Microservices architecture enables independent development, deployment, and scaling Containerization provides consistent environments across development and production Event-driven communication reduces coupling and improves resilience Observability is crucial for managing distributed systems effectively Automation throughout the development lifecycle improves quality and velocity Security must be built in from the ground up, not added as an afterthought Resilience patterns are essential for handling failures gracefully By adopting cloud native principles and practices with .NET and React Native using Podman and Red Hat UBI images, development teams can build scalable, resilient, and maintainable applications that fully leverage the benefits of cloud computing platforms. The investment in learning these practices pays dividends in improved development velocity, system reliability, and business agility.","title":"Cloud Native Development"},{"location":"1_cloud/cloud_native_development/#cloud-native-development","text":"","title":"Cloud Native Development"},{"location":"1_cloud/cloud_native_development/#overview","text":"Cloud native development represents a fundamental shift in how we build, deploy, and manage applications. It's an approach that fully embraces the cloud computing model, designing applications specifically to run in and take advantage of distributed, dynamic cloud environments. For junior and mid-senior developers working with .NET and React Native applications, understanding cloud native principles is essential for building scalable, resilient, and maintainable modern applications. Cloud native development goes beyond simply moving applications to the cloud\u2014it involves architecting applications as collections of loosely coupled services, using containers for packaging, and leveraging cloud platforms for orchestration, scaling, and management.","title":"Overview"},{"location":"1_cloud/cloud_native_development/#key-concepts","text":"","title":"Key Concepts"},{"location":"1_cloud/cloud_native_development/#the-four-pillars-of-cloud-native","text":"Microservices Architecture : Applications built as independent, loosely coupled services Containerization : Applications packaged in lightweight, portable containers DevOps and CI/CD : Automated build, test, and deployment pipelines Dynamic Orchestration : Container orchestration and service mesh technologies","title":"The Four Pillars of Cloud Native"},{"location":"1_cloud/cloud_native_development/#cloud-native-characteristics","text":"Scalability : Applications can scale horizontally across distributed infrastructure Resilience : Built-in fault tolerance and recovery mechanisms Observability : Comprehensive monitoring, logging, and tracing capabilities Automation : Infrastructure and deployment automation Portability : Applications run consistently across different cloud environments","title":"Cloud Native Characteristics"},{"location":"1_cloud/cloud_native_development/#cloud-native-vs-traditional-development","text":"Aspect Traditional Cloud Native Architecture Monolithic Microservices Deployment Manual/Scripted Automated CI/CD Scaling Vertical Horizontal Infrastructure Static/Physical Dynamic/Virtual State Management Stateful Stateless preferred Communication Direct calls API-first","title":"Cloud Native vs Traditional Development"},{"location":"1_cloud/cloud_native_development/#prerequisites","text":"Understanding of distributed systems concepts Familiarity with .NET Core/6+ and React Native Basic knowledge of containers and Podman Understanding of RESTful APIs and HTTP protocols Experience with version control (Git) and collaborative development","title":"Prerequisites"},{"location":"1_cloud/cloud_native_development/#required-tools-and-technologies","text":"Podman for containerization Red Hat UBI base images .NET 6+ for backend services React Native for mobile applications OpenShift or Kubernetes for orchestration Git for source control","title":"Required Tools and Technologies"},{"location":"1_cloud/cloud_native_development/#practical-examples","text":"","title":"Practical Examples"},{"location":"1_cloud/cloud_native_development/#example-1-cloud-native-net-microservice","text":"Let's build a cloud native order service that demonstrates key principles.","title":"Example 1: Cloud Native .NET Microservice"},{"location":"1_cloud/cloud_native_development/#step-1-design-the-service-architecture","text":"// OrderService/Models/Order.cs using System.ComponentModel.DataAnnotations ; namespace OrderService.Models { public class Order { public Guid Id { get ; set ; } = Guid . NewGuid (); [Required] public string CustomerId { get ; set ; } = string . Empty ; public List < OrderItem > Items { get ; set ; } = new (); public decimal TotalAmount => Items . Sum ( i => i . Price * i . Quantity ); public OrderStatus Status { get ; set ; } = OrderStatus . Pending ; public DateTime CreatedAt { get ; set ; } = DateTime . UtcNow ; public DateTime ? UpdatedAt { get ; set ; } } public class OrderItem { public Guid Id { get ; set ; } = Guid . NewGuid (); [Required] public string ProductId { get ; set ; } = string . Empty ; [Required] public string ProductName { get ; set ; } = string . Empty ; [Range(0.01, double.MaxValue)] public decimal Price { get ; set ; } [Range(1, int.MaxValue)] public int Quantity { get ; set ; } } public enum OrderStatus { Pending , Confirmed , Processing , Shipped , Delivered , Cancelled } }","title":"Step 1: Design the Service Architecture"},{"location":"1_cloud/cloud_native_development/#step-2-implement-cloud-native-patterns","text":"// OrderService/Controllers/OrdersController.cs using Microsoft.AspNetCore.Mvc ; using OrderService.Models ; using OrderService.Services ; namespace OrderService.Controllers { [ApiController] [Route(\"api/v1/[controller] \")] public class OrdersController : ControllerBase { private readonly IOrderService _orderService ; private readonly ILogger < OrdersController > _logger ; private readonly IConfiguration _configuration ; public OrdersController ( IOrderService orderService , ILogger < OrdersController > logger , IConfiguration configuration ) { _orderService = orderService ; _logger = logger ; _configuration = configuration ; } [HttpGet(\"health\")] public IActionResult HealthCheck () { return Ok ( new { status = \"healthy\" , timestamp = DateTime . UtcNow , version = _configuration [ \"App:Version\" ], environment = Environment . GetEnvironmentVariable ( \"ASPNETCORE_ENVIRONMENT\" ) }); } [HttpGet] public async Task < ActionResult < IEnumerable < Order >>> GetOrders ( [FromQuery] string? customerId = null , [FromQuery] int page = 1 , [FromQuery] int pageSize = 10 ) { try { _logger . LogInformation ( \"Retrieving orders for customer: {CustomerId}, Page: {Page}\" , customerId ?? \"all\" , page ); var orders = await _orderService . GetOrdersAsync ( customerId , page , pageSize ); Response . Headers . Add ( \"X-Total-Count\" , orders . TotalCount . ToString ()); Response . Headers . Add ( \"X-Page\" , page . ToString ()); Response . Headers . Add ( \"X-Page-Size\" , pageSize . ToString ()); return Ok ( orders . Items ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error retrieving orders\" ); return StatusCode ( 500 , new { error = \"Internal server error\" , traceId = Activity . Current ?. Id }); } } [HttpPost] public async Task < ActionResult < Order >> CreateOrder ([ FromBody ] CreateOrderRequest request ) { try { if ( ! ModelState . IsValid ) { return BadRequest ( ModelState ); } _logger . LogInformation ( \"Creating order for customer: {CustomerId}\" , request . CustomerId ); var order = await _orderService . CreateOrderAsync ( request ); // Publish domain event for other services await _orderService . PublishOrderCreatedEventAsync ( order ); return CreatedAtAction ( nameof ( GetOrderById ), new { id = order . Id }, order ); } catch ( BusinessValidationException ex ) { _logger . LogWarning ( ex , \"Business validation error creating order\" ); return BadRequest ( new { error = ex . Message }); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error creating order\" ); return StatusCode ( 500 , new { error = \"Internal server error\" , traceId = Activity . Current ?. Id }); } } [HttpGet(\"{id}\")] public async Task < ActionResult < Order >> GetOrderById ( Guid id ) { try { var order = await _orderService . GetOrderByIdAsync ( id ); if ( order == null ) { return NotFound ( new { error = $\"Order {id} not found\" }); } return Ok ( order ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error retrieving order {OrderId}\" , id ); return StatusCode ( 500 , new { error = \"Internal server error\" , traceId = Activity . Current ?. Id }); } } [HttpPut(\"{id}/status\")] public async Task < ActionResult < Order >> UpdateOrderStatus ( Guid id , [FromBody] UpdateOrderStatusRequest request ) { try { var order = await _orderService . UpdateOrderStatusAsync ( id , request . Status ); if ( order == null ) { return NotFound ( new { error = $\"Order {id} not found\" }); } // Publish status change event await _orderService . PublishOrderStatusChangedEventAsync ( order ); return Ok ( order ); } catch ( BusinessValidationException ex ) { _logger . LogWarning ( ex , \"Business validation error updating order status\" ); return BadRequest ( new { error = ex . Message }); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error updating order status for {OrderId}\" , id ); return StatusCode ( 500 , new { error = \"Internal server error\" , traceId = Activity . Current ?. Id }); } } } }","title":"Step 2: Implement Cloud Native Patterns"},{"location":"1_cloud/cloud_native_development/#step-3-implement-configuration-and-resilience","text":"// OrderService/Services/OrderService.cs using OrderService.Models ; using OrderService.Data ; using Microsoft.Extensions.Options ; using Polly ; using Polly.Extensions.Http ; namespace OrderService.Services { public interface IOrderService { Task < PagedResult < Order >> GetOrdersAsync ( string? customerId , int page , int pageSize ); Task < Order ?> GetOrderByIdAsync ( Guid id ); Task < Order > CreateOrderAsync ( CreateOrderRequest request ); Task < Order ?> UpdateOrderStatusAsync ( Guid id , OrderStatus status ); Task PublishOrderCreatedEventAsync ( Order order ); Task PublishOrderStatusChangedEventAsync ( Order order ); } public class OrderService : IOrderService { private readonly IOrderRepository _orderRepository ; private readonly ICustomerService _customerService ; private readonly IProductService _productService ; private readonly IEventPublisher _eventPublisher ; private readonly ILogger < OrderService > _logger ; private readonly OrderServiceOptions _options ; private readonly HttpClient _httpClient ; public OrderService ( IOrderRepository orderRepository , ICustomerService customerService , IProductService productService , IEventPublisher eventPublisher , ILogger < OrderService > logger , IOptions < OrderServiceOptions > options , HttpClient httpClient ) { _orderRepository = orderRepository ; _customerService = customerService ; _productService = productService ; _eventPublisher = eventPublisher ; _logger = logger ; _options = options . Value ; _httpClient = httpClient ; } public async Task < Order > CreateOrderAsync ( CreateOrderRequest request ) { // Validate customer exists var customer = await _customerService . GetCustomerAsync ( request . CustomerId ); if ( customer == null ) { throw new BusinessValidationException ( $\"Customer {request.CustomerId} not found\" ); } // Validate products and get current prices var validatedItems = new List < OrderItem > (); foreach ( var item in request . Items ) { var product = await _productService . GetProductAsync ( item . ProductId ); if ( product == null ) { throw new BusinessValidationException ( $\"Product {item.ProductId} not found\" ); } if ( product . StockQuantity < item . Quantity ) { throw new BusinessValidationException ( $\"Insufficient stock for product {product.Name}. Available: {product.StockQuantity}, Requested: {item.Quantity}\" ); } validatedItems . Add ( new OrderItem { ProductId = item . ProductId , ProductName = product . Name , Price = product . Price , // Use current price Quantity = item . Quantity }); } var order = new Order { CustomerId = request . CustomerId , Items = validatedItems , Status = OrderStatus . Pending }; // Reserve inventory await _productService . ReserveInventoryAsync ( order . Items ); // Save order await _orderRepository . CreateAsync ( order ); _logger . LogInformation ( \"Order {OrderId} created for customer {CustomerId} with total {Total:C}\" , order . Id , order . CustomerId , order . TotalAmount ); return order ; } public async Task PublishOrderCreatedEventAsync ( Order order ) { var eventData = new OrderCreatedEvent { OrderId = order . Id , CustomerId = order . CustomerId , TotalAmount = order . TotalAmount , Items = order . Items . Select ( i => new OrderItemEvent { ProductId = i . ProductId , Quantity = i . Quantity , Price = i . Price }). ToList (), CreatedAt = order . CreatedAt }; await _eventPublisher . PublishAsync ( \"order.created\" , eventData ); } // Additional resilience patterns public async Task < Product ?> GetProductWithRetryAsync ( string productId ) { var retryPolicy = Policy . Handle < HttpRequestException > () . Or < TaskCanceledException > () . WaitAndRetryAsync ( retryCount : 3 , sleepDurationProvider : retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( 2 , retryAttempt )), onRetry : ( outcome , timespan , retryCount , context ) => { _logger . LogWarning ( \"Retry {RetryCount} for product service call after {Delay}ms\" , retryCount , timespan . TotalMilliseconds ); }); return await retryPolicy . ExecuteAsync ( async () => { var response = await _httpClient . GetAsync ( $\"/api/products/{productId}\" ); response . EnsureSuccessStatusCode (); return await response . Content . ReadFromJsonAsync < Product > (); }); } } }","title":"Step 3: Implement Configuration and Resilience"},{"location":"1_cloud/cloud_native_development/#step-4-create-cloud-native-Containerfile","text":"# Use Red Hat UBI .NET 6 multi-stage build FROM registry.access.redhat.com/ubi8/dotnet-60 AS build # Set working directory WORKDIR /src # Copy project files and restore dependencies COPY [ \"OrderService/OrderService.csproj\" , \"OrderService/\" ] RUN dotnet restore \"OrderService/OrderService.csproj\" # Copy source code and build COPY . . WORKDIR \"/src/OrderService\" RUN dotnet build \"OrderService.csproj\" -c Release -o /app/build # Publish the application FROM build AS publish RUN dotnet publish \"OrderService.csproj\" -c Release -o /app/publish /p:UseAppHost = false # Create runtime image FROM registry.access.redhat.com/ubi8/dotnet-60-runtime AS runtime # Create non-root user for security RUN groupadd -r appuser && useradd -r -g appuser appuser # Set working directory and copy published app WORKDIR /app COPY --from = publish --chown = appuser:appuser /app/publish . # Install curl for health checks USER root RUN dnf update -y && dnf install -y curl && dnf clean all USER appuser # Configure application ENV ASPNETCORE_URLS = http://+:8080 ENV ASPNETCORE_ENVIRONMENT = Production EXPOSE 8080 # Add health check HEALTHCHECK --interval = 30s --timeout = 3s --start-period = 5s --retries = 3 \\ CMD curl -f http://localhost:8080/api/v1/orders/health || exit 1 # Set entrypoint ENTRYPOINT [ \"dotnet\" , \"OrderService.dll\" ]","title":"Step 4: Create Cloud Native Containerfile"},{"location":"1_cloud/cloud_native_development/#example-2-cloud-native-react-native-application","text":"Create a mobile app that consumes cloud native microservices.","title":"Example 2: Cloud Native React Native Application"},{"location":"1_cloud/cloud_native_development/#step-1-implement-api-client-with-resilience","text":"// src/services/ApiClient.ts import axios , { AxiosInstance , AxiosRequestConfig , AxiosResponse } from 'axios' ; import AsyncStorage from '@react-native-async-storage/async-storage' ; export interface ApiConfig { baseURL : string ; timeout : number ; maxRetries : number ; retryDelay : number ; } export class ApiClient { private client : AxiosInstance ; private config : ApiConfig ; constructor ( config : ApiConfig ) { this . config = config ; this . client = axios . create ({ baseURL : config.baseURL , timeout : config.timeout , headers : { 'Content-Type' : 'application/json' , 'Accept' : 'application/json' , }, }); this . setupInterceptors (); } private setupInterceptors () : void { // Request interceptor for authentication this . client . interceptors . request . use ( async ( config ) => { const token = await AsyncStorage . getItem ( 'authToken' ); if ( token ) { config . headers . Authorization = `Bearer ${ token } ` ; } // Add correlation ID for distributed tracing config . headers [ 'X-Correlation-ID' ] = this . generateCorrelationId (); console . log ( `\ud83d\ude80 API Request: ${ config . method ? . toUpperCase () } ${ config . url } ` ); return config ; }, ( error ) => { console . error ( '\u274c Request interceptor error:' , error ); return Promise . reject ( error ); } ); // Response interceptor for error handling and retry logic this . client . interceptors . response . use ( ( response ) => { console . log ( `\u2705 API Response: ${ response . status } ${ response . config . url } ` ); return response ; }, async ( error ) => { const originalRequest = error . config ; if ( error . response ? . status === 401 && ! originalRequest . _retry ) { originalRequest . _retry = true ; await this . handleUnauthorized (); return this . client ( originalRequest ); } if ( this . shouldRetry ( error ) && ! originalRequest . _retryCount ) { return this . retryRequest ( originalRequest ); } console . error ( '\u274c API Error:' , error . response ? . data || error . message ); return Promise . reject ( this . normalizeError ( error )); } ); } private shouldRetry ( error : any ) : boolean { return ( error . code === 'NETWORK_ERROR' || error . code === 'TIMEOUT' || ( error . response && error . response . status >= 500 ) ); } private async retryRequest ( originalRequest : any ) : Promise < AxiosResponse > { originalRequest . _retryCount = ( originalRequest . _retryCount || 0 ) + 1 ; if ( originalRequest . _retryCount > this . config . maxRetries ) { throw new Error ( `Max retries ( ${ this . config . maxRetries } ) exceeded` ); } const delay = this . config . retryDelay * Math . pow ( 2 , originalRequest . _retryCount - 1 ); console . log ( `\ud83d\udd04 Retrying request ${ originalRequest . _retryCount } / ${ this . config . maxRetries } after ${ delay } ms` ); await new Promise ( resolve => setTimeout ( resolve , delay )); return this . client ( originalRequest ); } private async handleUnauthorized () : Promise < void > { await AsyncStorage . removeItem ( 'authToken' ); await AsyncStorage . removeItem ( 'refreshToken' ); // Navigate to login screen // NavigationService.navigate('Login'); } private normalizeError ( error : any ) : ApiError { return { message : error.response?.data?.error || error . message || 'An unexpected error occurred' , status : error.response?.status , traceId : error.response?.data?.traceId , correlationId : error.config?.headers [ 'X-Correlation-ID' ], }; } private generateCorrelationId () : string { return `mobile- ${ Date . now () } - ${ Math . random (). toString ( 36 ). substr ( 2 , 9 ) } ` ; } // Public API methods public async get < T > ( url : string , config? : AxiosRequestConfig ) : Promise < T > { const response = await this . client . get < T > ( url , config ); return response . data ; } public async post < T > ( url : string , data? : any , config? : AxiosRequestConfig ) : Promise < T > { const response = await this . client . post < T > ( url , data , config ); return response . data ; } public async put < T > ( url : string , data? : any , config? : AxiosRequestConfig ) : Promise < T > { const response = await this . client . put < T > ( url , data , config ); return response . data ; } public async delete < T > ( url : string , config? : AxiosRequestConfig ) : Promise < T > { const response = await this . client . delete < T > ( url , config ); return response . data ; } } export interface ApiError { message : string ; status? : number ; traceId? : string ; correlationId? : string ; } // Service factory export const createApiClient = ( environment : 'development' | 'staging' | 'production' ) : ApiClient => { const configs = { development : { baseURL : 'http://localhost:8080/api/v1' , timeout : 10000 , maxRetries : 2 , retryDelay : 1000 , }, staging : { baseURL : 'https://api-staging.example.com/api/v1' , timeout : 15000 , maxRetries : 3 , retryDelay : 1000 , }, production : { baseURL : 'https://api.example.com/api/v1' , timeout : 15000 , maxRetries : 3 , retryDelay : 1000 , }, }; return new ApiClient ( configs [ environment ]); };","title":"Step 1: Implement API Client with Resilience"},{"location":"1_cloud/cloud_native_development/#step-2-implement-domain-services","text":"// src/services/OrderService.ts import { ApiClient , ApiError } from './ApiClient' ; export interface Order { id : string ; customerId : string ; items : OrderItem []; totalAmount : number ; status : OrderStatus ; createdAt : string ; updatedAt? : string ; } export interface OrderItem { id : string ; productId : string ; productName : string ; price : number ; quantity : number ; } export interface CreateOrderRequest { customerId : string ; items : CreateOrderItemRequest []; } export interface CreateOrderItemRequest { productId : string ; quantity : number ; } export enum OrderStatus { Pending = 'Pending' , Confirmed = 'Confirmed' , Processing = 'Processing' , Shipped = 'Shipped' , Delivered = 'Delivered' , Cancelled = 'Cancelled' , } export class OrderService { constructor ( private apiClient : ApiClient ) {} async getOrders ( customerId? : string , page : number = 1 , pageSize : number = 10 ) : Promise < Order [] > { try { const params = new URLSearchParams ({ page : page.toString (), pageSize : pageSize.toString (), }); if ( customerId ) { params . append ( 'customerId' , customerId ); } return await this . apiClient . get < Order [] > ( `/orders? ${ params . toString () } ` ); } catch ( error ) { console . error ( 'Failed to fetch orders:' , error ); throw this . handleServiceError ( error , 'Failed to load orders' ); } } async getOrderById ( orderId : string ) : Promise < Order > { try { return await this . apiClient . get < Order > ( `/orders/ ${ orderId } ` ); } catch ( error ) { console . error ( `Failed to fetch order ${ orderId } :` , error ); throw this . handleServiceError ( error , 'Failed to load order details' ); } } async createOrder ( request : CreateOrderRequest ) : Promise < Order > { try { return await this . apiClient . post < Order > ( '/orders' , request ); } catch ( error ) { console . error ( 'Failed to create order:' , error ); throw this . handleServiceError ( error , 'Failed to create order' ); } } async updateOrderStatus ( orderId : string , status : OrderStatus ) : Promise < Order > { try { return await this . apiClient . put < Order > ( `/orders/ ${ orderId } /status` , { status }); } catch ( error ) { console . error ( `Failed to update order ${ orderId } status:` , error ); throw this . handleServiceError ( error , 'Failed to update order status' ); } } private handleServiceError ( error : any , defaultMessage : string ) : ServiceError { if ( error . status === 404 ) { return new ServiceError ( 'Order not found' , 'NOT_FOUND' ); } if ( error . status === 400 ) { return new ServiceError ( error . message || 'Invalid request' , 'VALIDATION_ERROR' ); } if ( error . status >= 500 ) { return new ServiceError ( 'Service temporarily unavailable' , 'SERVER_ERROR' ); } return new ServiceError ( defaultMessage , 'UNKNOWN_ERROR' ); } } export class ServiceError extends Error { constructor ( message : string , public readonly code : string , public readonly originalError? : any ) { super ( message ); this . name = 'ServiceError' ; } }","title":"Step 2: Implement Domain Services"},{"location":"1_cloud/cloud_native_development/#example-3-podman-compose-for-development","text":"Create a development environment that mirrors production: # compose.yml version : '3.8' services : # API Gateway / Load Balancer nginx : image : registry.access.redhat.com/ubi8/nginx-120 ports : - \"8080:8080\" volumes : - ./nginx/nginx.conf:/etc/nginx/nginx.conf:Z depends_on : - order-service - product-service - customer-service networks : - app-network # Order Service order-service : build : context : ./OrderService Containerfile : Containerfile.dev environment : - ASPNETCORE_ENVIRONMENT=Development - ConnectionStrings__DefaultConnection=Host=postgres;Database=orderdb;Username=orderuser;Password=orderpass - Services__CustomerService__BaseUrl=http://customer-service:8080 - Services__ProductService__BaseUrl=http://product-service:8080 - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 ports : - \"5001:8080\" depends_on : - postgres - rabbitmq volumes : - ./OrderService:/app:Z networks : - app-network # Product Service product-service : build : context : ./ProductService Containerfile : Containerfile.dev environment : - ASPNETCORE_ENVIRONMENT=Development - ConnectionStrings__DefaultConnection=Host=postgres;Database=productdb;Username=productuser;Password=productpass - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 ports : - \"5002:8080\" depends_on : - postgres - rabbitmq volumes : - ./ProductService:/app:Z networks : - app-network # Customer Service customer-service : build : context : ./CustomerService Containerfile : Containerfile.dev environment : - ASPNETCORE_ENVIRONMENT=Development - ConnectionStrings__DefaultConnection=Host=postgres;Database=customerdb;Username=customeruser;Password=customerpass ports : - \"5003:8080\" depends_on : - postgres volumes : - ./CustomerService:/app:Z networks : - app-network # PostgreSQL Database postgres : image : registry.access.redhat.com/rhel8/postgresql-13 environment : - POSTGRESQL_USER=postgres - POSTGRESQL_PASSWORD=postgres - POSTGRESQL_DATABASE=postgres ports : - \"5432:5432\" volumes : - postgres_data:/var/lib/pgsql/data - ./database/init-scripts:/docker-entrypoint-initdb.d:Z networks : - app-network # RabbitMQ for event-driven communication rabbitmq : image : registry.access.redhat.com/ubi8/ubi:latest command : | bash -c \" dnf install -y rabbitmq-server && systemctl enable rabbitmq-server && rabbitmq-server \" environment : - RABBITMQ_DEFAULT_USER=guest - RABBITMQ_DEFAULT_PASS=guest ports : - \"5672:5672\" - \"15672:15672\" volumes : - rabbitmq_data:/var/lib/rabbitmq networks : - app-network # Redis for caching redis : image : registry.access.redhat.com/rhel8/redis-6 ports : - \"6379:6379\" volumes : - redis_data:/var/lib/redis/data networks : - app-network # Monitoring and Observability prometheus : image : prom/prometheus:latest ports : - \"9090:9090\" volumes : - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:Z - prometheus_data:/prometheus networks : - app-network grafana : image : grafana/grafana:latest ports : - \"3000:3000\" environment : - GF_SECURITY_ADMIN_PASSWORD=admin volumes : - grafana_data:/var/lib/grafana - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:Z - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:Z networks : - app-network volumes : postgres_data : rabbitmq_data : redis_data : prometheus_data : grafana_data : networks : app-network : driver : bridge","title":"Example 3: podman compose  for Development"},{"location":"1_cloud/cloud_native_development/#common-pitfalls","text":"","title":"Common Pitfalls"},{"location":"1_cloud/cloud_native_development/#1-monolithic-thinking-in-microservices","text":"Problem : Creating \"distributed monoliths\" where services are too tightly coupled. Solution : Design services around business capabilities, not technical layers: // BAD: Technical layer separation public class UserController { /* All user operations */ } public class OrderController { /* All order operations */ } public class ProductController { /* All product operations */ } // GOOD: Business capability separation public class CustomerManagementService { /* Customer lifecycle */ } public class OrderProcessingService { /* Order workflow */ } public class InventoryManagementService { /* Stock management */ }","title":"1. Monolithic Thinking in Microservices"},{"location":"1_cloud/cloud_native_development/#2-ignoring-data-consistency","text":"Problem : Not properly handling distributed data consistency across services. Solution : Implement eventual consistency patterns and saga patterns: // Saga pattern implementation public class OrderProcessingSaga { public async Task ProcessOrderAsync ( Order order ) { var compensationActions = new List < Func < Task >> (); try { // Reserve inventory await _inventoryService . ReserveItemsAsync ( order . Items ); compensationActions . Add (() => _inventoryService . ReleaseReservationAsync ( order . Id )); // Process payment await _paymentService . ProcessPaymentAsync ( order . CustomerId , order . TotalAmount ); compensationActions . Add (() => _paymentService . RefundPaymentAsync ( order . Id )); // Confirm order await _orderService . ConfirmOrderAsync ( order . Id ); } catch ( Exception ex ) { // Execute compensation actions in reverse order compensationActions . Reverse (); foreach ( var action in compensationActions ) { try { await action (); } catch ( Exception compensationEx ) { _logger . LogError ( compensationEx , \"Compensation action failed\" ); } } throw ; } } }","title":"2. Ignoring Data Consistency"},{"location":"1_cloud/cloud_native_development/#3-poor-service-communication","text":"Problem : Synchronous communication causing cascading failures. Solution : Use asynchronous messaging and circuit breaker patterns: public class ResilientServiceClient { private readonly IAsyncPolicy < HttpResponseMessage > _retryPolicy ; private readonly IAsyncPolicy < HttpResponseMessage > _circuitBreakerPolicy ; public ResilientServiceClient () { _retryPolicy = Policy . HandleResult < HttpResponseMessage > ( r => ! r . IsSuccessStatusCode ) . WaitAndRetryAsync ( 3 , retryAttempt => TimeSpan . FromSeconds ( Math . Pow ( 2 , retryAttempt ))); _circuitBreakerPolicy = Policy . HandleResult < HttpResponseMessage > ( r => ! r . IsSuccessStatusCode ) . CircuitBreakerAsync ( 5 , TimeSpan . FromSeconds ( 30 )); } public async Task < T > GetAsync < T > ( string endpoint ) { var response = await _retryPolicy . WrapAsync ( _circuitBreakerPolicy ) . ExecuteAsync (() => _httpClient . GetAsync ( endpoint )); response . EnsureSuccessStatusCode (); return await response . Content . ReadFromJsonAsync < T > (); } }","title":"3. Poor Service Communication"},{"location":"1_cloud/cloud_native_development/#4-inadequate-observability","text":"Problem : Lack of proper monitoring, logging, and tracing in distributed systems. Solution : Implement comprehensive observability from the start: // Structured logging with correlation IDs public class OrderController : ControllerBase { public async Task < IActionResult > CreateOrder ([ FromBody ] CreateOrderRequest request ) { var correlationId = HttpContext . Items [ \"CorrelationId\" ] ?. ToString (); using var scope = _logger . BeginScope ( new Dictionary < string , object > { [\"CorrelationId\"] = correlationId , [\"Operation\"] = \"CreateOrder\" , [\"CustomerId\"] = request . CustomerId }); _logger . LogInformation ( \"Creating order for customer {CustomerId} with {ItemCount} items\" , request . CustomerId , request . Items . Count ); try { var order = await _orderService . CreateOrderAsync ( request ); _logger . LogInformation ( \"Order {OrderId} created successfully with total {Total:C}\" , order . Id , order . TotalAmount ); return CreatedAtAction ( nameof ( GetOrderById ), new { id = order . Id }, order ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Failed to create order for customer {CustomerId}\" , request . CustomerId ); throw ; } } }","title":"4. Inadequate Observability"},{"location":"1_cloud/cloud_native_development/#best-practices","text":"","title":"Best Practices"},{"location":"1_cloud/cloud_native_development/#1-design-for-failure","text":"Implement circuit breakers and retries Use bulkhead patterns to isolate failures Design graceful degradation strategies Implement health checks and readiness probes","title":"1. Design for Failure"},{"location":"1_cloud/cloud_native_development/#2-configuration-management","text":"// Environment-specific configuration public class ServiceConfiguration { public string ConnectionString { get ; set ; } public int TimeoutMs { get ; set ; } public int MaxRetries { get ; set ; } public bool EnableCircuitBreaker { get ; set ; } public static ServiceConfiguration FromEnvironment () { return new ServiceConfiguration { ConnectionString = Environment . GetEnvironmentVariable ( \"CONNECTION_STRING\" ) ?? throw new InvalidOperationException ( \"CONNECTION_STRING not configured\" ), TimeoutMs = int . Parse ( Environment . GetEnvironmentVariable ( \"TIMEOUT_MS\" ) ?? \"30000\" ), MaxRetries = int . Parse ( Environment . GetEnvironmentVariable ( \"MAX_RETRIES\" ) ?? \"3\" ), EnableCircuitBreaker = bool . Parse ( Environment . GetEnvironmentVariable ( \"ENABLE_CIRCUIT_BREAKER\" ) ?? \"true\" ) }; } }","title":"2. Configuration Management"},{"location":"1_cloud/cloud_native_development/#3-api-versioning","text":"// API versioning strategy [ApiController] [ApiVersion(\"1.0\")] [ApiVersion(\"2.0\")] [Route(\"api/v{version:apiVersion}/[controller] \")] public class OrdersController : ControllerBase { [HttpGet] [MapToApiVersion(\"1.0\")] public async Task < ActionResult < IEnumerable < OrderV1 >>> GetOrdersV1 () { // Legacy implementation } [HttpGet] [MapToApiVersion(\"2.0\")] public async Task < ActionResult < PagedResult < OrderV2 >>> GetOrdersV2 ( [FromQuery] int page = 1 , [FromQuery] int pageSize = 10 ) { // Enhanced implementation with pagination } }","title":"3. API Versioning"},{"location":"1_cloud/cloud_native_development/#4-security","text":"Use HTTPS everywhere Implement proper authentication and authorization Validate all inputs Use secrets management Scan containers for vulnerabilities","title":"4. Security"},{"location":"1_cloud/cloud_native_development/#tools-and-resources","text":"","title":"Tools and Resources"},{"location":"1_cloud/cloud_native_development/#development-tools","text":"Podman : Container runtime and management podman compose  : Multi-container application orchestration Visual Studio Code : IDE with container extensions Postman : API testing and documentation .NET CLI : Command-line development tools","title":"Development Tools"},{"location":"1_cloud/cloud_native_development/#monitoring-and-observability","text":"Prometheus : Metrics collection Grafana : Metrics visualization Jaeger : Distributed tracing ELK Stack : Centralized logging Application Insights : APM for .NET","title":"Monitoring and Observability"},{"location":"1_cloud/cloud_native_development/#useful-resources","text":"Cloud Native Computing Foundation 12-Factor App Methodology Microservices Pattern Library Podman Documentation .NET Microservices Guide","title":"Useful Resources"},{"location":"1_cloud/cloud_native_development/#hands-on-exercise","text":"","title":"Hands-on Exercise"},{"location":"1_cloud/cloud_native_development/#exercise-build-a-complete-cloud-native-e-commerce-platform","text":"Create a full-featured e-commerce platform demonstrating cloud native principles. Requirements: Microservices Architecture: User management service Product catalog service Shopping cart service Order processing service Payment service Notification service Technology Stack: .NET 6+ for backend services React Native for mobile app PostgreSQL for data persistence Redis for caching RabbitMQ for event-driven communication Cloud Native Features: Containerized with Podman and UBI images Health checks and readiness probes Configuration externalization Distributed tracing and monitoring API gateway and service discovery Event-driven architecture Non-functional Requirements: Handle 1000 concurrent users 99.9% availability Sub-100ms API response times Comprehensive observability Security best practices Deliverables: Complete microservices implementation Mobile application with offline capabilities Deployment configuration for development and production Monitoring and alerting setup Performance testing results Security assessment report Comprehensive documentation","title":"Exercise: Build a Complete Cloud Native E-commerce Platform"},{"location":"1_cloud/cloud_native_development/#summary","text":"Cloud native development represents a fundamental shift in software architecture and development practices. Key takeaways include: Microservices architecture enables independent development, deployment, and scaling Containerization provides consistent environments across development and production Event-driven communication reduces coupling and improves resilience Observability is crucial for managing distributed systems effectively Automation throughout the development lifecycle improves quality and velocity Security must be built in from the ground up, not added as an afterthought Resilience patterns are essential for handling failures gracefully By adopting cloud native principles and practices with .NET and React Native using Podman and Red Hat UBI images, development teams can build scalable, resilient, and maintainable applications that fully leverage the benefits of cloud computing platforms. The investment in learning these practices pays dividends in improved development velocity, system reliability, and business agility.","title":"Summary"},{"location":"1_cloud/cncf/","text":"","title":"CNCF Landscape"},{"location":"1_cloud/hybrid_cloud/","text":"","title":"Hybrid Cloud"},{"location":"2_containerization/container_engines_crio/","text":"","title":"CRI-O Container Engine"},{"location":"2_containerization/containers/","text":"Container Fundamentals with Podman \u00b6 Overview \u00b6 Containers have revolutionized software development by providing consistent, lightweight, and portable environments for applications. This guide focuses on container fundamentals using Podman , an open-source, daemonless container engine that's particularly relevant for junior and mid-senior developers working with .NET and React Native applications. Unlike Docker, Podman runs without a daemon and provides enhanced security through rootless containers, making it an ideal choice for modern development practices. Key Concepts \u00b6 What are Containers? \u00b6 Containers are lightweight, standalone packages that include everything needed to run an application: - Application code - Runtime environment - System tools and libraries - Settings and dependencies Podman vs Docker \u00b6 Feature Podman Docker Architecture Daemonless Daemon-based Root privileges Rootless by default Requires root/daemon Security Enhanced security Standard container security Compatibility Docker-compatible CLI Native Docker Systemd integration Native support Limited Container Images \u00b6 Container images are templates used to create containers. For this documentation, we exclusively use Red Hat Universal Base Images (UBI) which provide: - Enterprise-grade security - Regular security updates - Compliance with enterprise standards - Free redistribution rights Prerequisites \u00b6 Basic understanding of command-line operations Podman installed on your development machine Access to container registries (Red Hat Container Catalog) Understanding of application deployment concepts Installing Podman \u00b6 # On RHEL/CentOS/Fedora sudo dnf install podman # On Ubuntu/Debian sudo apt-get update sudo apt-get install podman # On macOS brew install podman Practical Examples \u00b6 Example 1: Running a .NET Application with UBI \u00b6 Let's create a simple .NET Web API using Red Hat UBI base images. Step 1: Create a Simple .NET API \u00b6 First, create a new .NET Web API project: mkdir dotnet-container-demo cd dotnet-container-demo dotnet new webapi -n MyApi cd MyApi Step 2: Create a Containerfile with UBI \u00b6 # Use Red Hat UBI .NET 6.0 runtime image FROM registry.access.redhat.com/ubi8/dotnet-60-runtime # Set the working directory WORKDIR /app # Copy the published application COPY bin/Release/net6.0/publish/ . # Expose the port EXPOSE 5000 # Set environment variables ENV ASPNETCORE_URLS = http://+:5000 ENV ASPNETCORE_ENVIRONMENT = Production # Create a non-root user for security RUN groupadd -r appuser && useradd -r -g appuser appuser RUN chown -R appuser:appuser /app USER appuser # Set the entry point ENTRYPOINT [ \"dotnet\" , \"MyApi.dll\" ] Step 3: Build and Publish the Application \u00b6 # Publish the application dotnet publish -c Release # Build the container image with Podman podman build -t myapi:latest . # Run the container podman run -d --name myapi-container -p 5000 :5000 myapi:latest Step 4: Test the Application \u00b6 # Test the API endpoint curl http://localhost:5000/weatherforecast # View container logs podman logs myapi-container # Stop and remove the container podman stop myapi-container podman rm myapi-container Example 2: React Native Development Environment \u00b6 Create a development environment for React Native using UBI Node.js images: # Use Red Hat UBI Node.js 16 image FROM registry.access.redhat.com/ubi8/nodejs-16 # Set working directory WORKDIR /app # Install React Native CLI globally USER root RUN npm install -g @react-native-community/cli # Create app user and switch to it RUN groupadd -r appuser && useradd -r -g appuser appuser RUN chown -R appuser:appuser /app USER appuser # Copy package files COPY --chown = appuser:appuser package*.json ./ # Install dependencies RUN npm install # Copy source code COPY --chown = appuser:appuser . . # Expose Metro bundler port EXPOSE 8081 # Start the Metro bundler CMD [ \"npm\" , \"start\" ] Build and run the React Native development container: # Build the development image podman build -t react-native-dev:latest -f Containerfile.dev . # Run the development container with volume mounting podman run -d \\ --name rn-dev \\ -p 8081 :8081 \\ -v $( pwd ) :/app:Z \\ react-native-dev:latest Common Pitfalls \u00b6 1. Rootless Container Permissions \u00b6 Problem : Permission errors when mounting volumes or accessing files. Solution : Use proper SELinux contexts and understand rootless user mapping: # Use :Z flag for SELinux contexts podman run -v $( pwd ) :/app:Z myimage # Check user mapping podman unshare cat /proc/self/uid_map 2. Network Connectivity Issues \u00b6 Problem : Containers can't communicate with each other or external services. Solution : Use Podman networks properly: # Create a custom network podman network create myapp-network # Run containers on the same network podman run -d --network myapp-network --name api myapi:latest podman run -d --network myapp-network --name frontend myfrontend:latest 3. Image Size Optimization \u00b6 Problem : Large container images slow down builds and deployments. Solution : Use multi-stage builds and minimal base images: # Multi-stage build for .NET FROM registry.access.redhat.com/ubi8/dotnet-60 AS build WORKDIR /src COPY *.csproj . RUN dotnet restore COPY . . RUN dotnet publish -c Release -o /app/publish FROM registry.access.redhat.com/ubi8/dotnet-60-runtime AS runtime WORKDIR /app COPY --from = build /app/publish . ENTRYPOINT [ \"dotnet\" , \"MyApi.dll\" ] Best Practices \u00b6 Security Best Practices \u00b6 Use Rootless Containers : Run Podman without root privileges Non-root User : Always run applications as non-root users inside containers Minimal Base Images : Use UBI minimal images when possible Regular Updates : Keep base images updated with security patches Secrets Management : Never include secrets in images # Example of secure container setup FROM registry.access.redhat.com/ubi8/dotnet-60-runtime # Create non-root user RUN groupadd -r appuser && useradd -r -g appuser appuser WORKDIR /app COPY --chown = appuser:appuser . . # Switch to non-root user USER appuser ENTRYPOINT [ \"dotnet\" , \"MyApp.dll\" ] Performance Best Practices \u00b6 Layer Caching : Order Containerfile instructions to maximize cache hits Multi-stage Builds : Separate build and runtime environments Minimize Layers : Combine RUN commands when logical .containerignore : Exclude unnecessary files from build context Example .containerignore : node_modules .git * .md .gitignore Containerfile * * .log Development Workflow \u00b6 Local Development : Use volume mounts for hot reloading Testing : Create separate images for testing environments Debugging : Use interactive shells for troubleshooting # Interactive debugging session podman run -it --rm myimage /bin/bash # Run with development volume mounts podman run -d \\ -v $( pwd ) :/app:Z \\ -p 5000 :5000 \\ --name dev-container \\ myapi:dev Tools and Resources \u00b6 Essential Podman Commands \u00b6 # Image management podman images # List images podman pull image:tag # Pull image podman rmi image:tag # Remove image podman build -t name:tag . # Build image # Container management podman ps # List running containers podman ps -a # List all containers podman run [ options ] image # Run container podman stop container # Stop container podman rm container # Remove container # Networking podman network ls # List networks podman network create name # Create network podman port container # Show port mappings # Troubleshooting podman logs container # View logs podman exec -it container bash # Interactive shell podman inspect container # Detailed information Useful Resources \u00b6 Podman Official Documentation Red Hat UBI Images Container Best Practices Rootless Containers Guide Hands-on Exercise \u00b6 Exercise: Containerize a Full-Stack Application \u00b6 Create a multi-container application with: 1. .NET Web API backend 2. React frontend 3. PostgreSQL database Requirements : - Use only Red Hat UBI base images - Implement proper security practices (non-root users) - Use Podman networks for container communication - Include proper error handling and logging - Create a podman compose  file for orchestration Steps : Create the .NET API with Entity Framework Create a React frontend that consumes the API Set up PostgreSQL with proper initialization Create Containerfiles for each component Create a compose.yml file Test the complete application stack Deliverables : - Working containerized application - Documentation of the containerization process - Security analysis of the implementation - Performance testing results Summary \u00b6 Container fundamentals with Podman provide the foundation for modern application development and deployment. Key takeaways include: Podman offers enhanced security through rootless containers and daemonless architecture Red Hat UBI images provide enterprise-grade security and compliance Proper security practices include non-root users and minimal base images Multi-stage builds optimize image size and security Container orchestration enables complex application architectures Development workflows benefit from containerization through consistency and portability By mastering these container fundamentals, developers can build secure, scalable, and maintainable applications that follow modern DevOps practices and integrate seamlessly with cloud-native architectures.","title":"Container Fundamentals"},{"location":"2_containerization/containers/#container-fundamentals-with-podman","text":"","title":"Container Fundamentals with Podman"},{"location":"2_containerization/containers/#overview","text":"Containers have revolutionized software development by providing consistent, lightweight, and portable environments for applications. This guide focuses on container fundamentals using Podman , an open-source, daemonless container engine that's particularly relevant for junior and mid-senior developers working with .NET and React Native applications. Unlike Docker, Podman runs without a daemon and provides enhanced security through rootless containers, making it an ideal choice for modern development practices.","title":"Overview"},{"location":"2_containerization/containers/#key-concepts","text":"","title":"Key Concepts"},{"location":"2_containerization/containers/#what-are-containers","text":"Containers are lightweight, standalone packages that include everything needed to run an application: - Application code - Runtime environment - System tools and libraries - Settings and dependencies","title":"What are Containers?"},{"location":"2_containerization/containers/#podman-vs-docker","text":"Feature Podman Docker Architecture Daemonless Daemon-based Root privileges Rootless by default Requires root/daemon Security Enhanced security Standard container security Compatibility Docker-compatible CLI Native Docker Systemd integration Native support Limited","title":"Podman vs Docker"},{"location":"2_containerization/containers/#container-images","text":"Container images are templates used to create containers. For this documentation, we exclusively use Red Hat Universal Base Images (UBI) which provide: - Enterprise-grade security - Regular security updates - Compliance with enterprise standards - Free redistribution rights","title":"Container Images"},{"location":"2_containerization/containers/#prerequisites","text":"Basic understanding of command-line operations Podman installed on your development machine Access to container registries (Red Hat Container Catalog) Understanding of application deployment concepts","title":"Prerequisites"},{"location":"2_containerization/containers/#installing-podman","text":"# On RHEL/CentOS/Fedora sudo dnf install podman # On Ubuntu/Debian sudo apt-get update sudo apt-get install podman # On macOS brew install podman","title":"Installing Podman"},{"location":"2_containerization/containers/#practical-examples","text":"","title":"Practical Examples"},{"location":"2_containerization/containers/#example-1-running-a-net-application-with-ubi","text":"Let's create a simple .NET Web API using Red Hat UBI base images.","title":"Example 1: Running a .NET Application with UBI"},{"location":"2_containerization/containers/#step-1-create-a-simple-net-api","text":"First, create a new .NET Web API project: mkdir dotnet-container-demo cd dotnet-container-demo dotnet new webapi -n MyApi cd MyApi","title":"Step 1: Create a Simple .NET API"},{"location":"2_containerization/containers/#step-2-create-a-Containerfile-with-ubi","text":"# Use Red Hat UBI .NET 6.0 runtime image FROM registry.access.redhat.com/ubi8/dotnet-60-runtime # Set the working directory WORKDIR /app # Copy the published application COPY bin/Release/net6.0/publish/ . # Expose the port EXPOSE 5000 # Set environment variables ENV ASPNETCORE_URLS = http://+:5000 ENV ASPNETCORE_ENVIRONMENT = Production # Create a non-root user for security RUN groupadd -r appuser && useradd -r -g appuser appuser RUN chown -R appuser:appuser /app USER appuser # Set the entry point ENTRYPOINT [ \"dotnet\" , \"MyApi.dll\" ]","title":"Step 2: Create a Containerfile with UBI"},{"location":"2_containerization/containers/#step-3-build-and-publish-the-application","text":"# Publish the application dotnet publish -c Release # Build the container image with Podman podman build -t myapi:latest . # Run the container podman run -d --name myapi-container -p 5000 :5000 myapi:latest","title":"Step 3: Build and Publish the Application"},{"location":"2_containerization/containers/#step-4-test-the-application","text":"# Test the API endpoint curl http://localhost:5000/weatherforecast # View container logs podman logs myapi-container # Stop and remove the container podman stop myapi-container podman rm myapi-container","title":"Step 4: Test the Application"},{"location":"2_containerization/containers/#example-2-react-native-development-environment","text":"Create a development environment for React Native using UBI Node.js images: # Use Red Hat UBI Node.js 16 image FROM registry.access.redhat.com/ubi8/nodejs-16 # Set working directory WORKDIR /app # Install React Native CLI globally USER root RUN npm install -g @react-native-community/cli # Create app user and switch to it RUN groupadd -r appuser && useradd -r -g appuser appuser RUN chown -R appuser:appuser /app USER appuser # Copy package files COPY --chown = appuser:appuser package*.json ./ # Install dependencies RUN npm install # Copy source code COPY --chown = appuser:appuser . . # Expose Metro bundler port EXPOSE 8081 # Start the Metro bundler CMD [ \"npm\" , \"start\" ] Build and run the React Native development container: # Build the development image podman build -t react-native-dev:latest -f Containerfile.dev . # Run the development container with volume mounting podman run -d \\ --name rn-dev \\ -p 8081 :8081 \\ -v $( pwd ) :/app:Z \\ react-native-dev:latest","title":"Example 2: React Native Development Environment"},{"location":"2_containerization/containers/#common-pitfalls","text":"","title":"Common Pitfalls"},{"location":"2_containerization/containers/#1-rootless-container-permissions","text":"Problem : Permission errors when mounting volumes or accessing files. Solution : Use proper SELinux contexts and understand rootless user mapping: # Use :Z flag for SELinux contexts podman run -v $( pwd ) :/app:Z myimage # Check user mapping podman unshare cat /proc/self/uid_map","title":"1. Rootless Container Permissions"},{"location":"2_containerization/containers/#2-network-connectivity-issues","text":"Problem : Containers can't communicate with each other or external services. Solution : Use Podman networks properly: # Create a custom network podman network create myapp-network # Run containers on the same network podman run -d --network myapp-network --name api myapi:latest podman run -d --network myapp-network --name frontend myfrontend:latest","title":"2. Network Connectivity Issues"},{"location":"2_containerization/containers/#3-image-size-optimization","text":"Problem : Large container images slow down builds and deployments. Solution : Use multi-stage builds and minimal base images: # Multi-stage build for .NET FROM registry.access.redhat.com/ubi8/dotnet-60 AS build WORKDIR /src COPY *.csproj . RUN dotnet restore COPY . . RUN dotnet publish -c Release -o /app/publish FROM registry.access.redhat.com/ubi8/dotnet-60-runtime AS runtime WORKDIR /app COPY --from = build /app/publish . ENTRYPOINT [ \"dotnet\" , \"MyApi.dll\" ]","title":"3. Image Size Optimization"},{"location":"2_containerization/containers/#best-practices","text":"","title":"Best Practices"},{"location":"2_containerization/containers/#security-best-practices","text":"Use Rootless Containers : Run Podman without root privileges Non-root User : Always run applications as non-root users inside containers Minimal Base Images : Use UBI minimal images when possible Regular Updates : Keep base images updated with security patches Secrets Management : Never include secrets in images # Example of secure container setup FROM registry.access.redhat.com/ubi8/dotnet-60-runtime # Create non-root user RUN groupadd -r appuser && useradd -r -g appuser appuser WORKDIR /app COPY --chown = appuser:appuser . . # Switch to non-root user USER appuser ENTRYPOINT [ \"dotnet\" , \"MyApp.dll\" ]","title":"Security Best Practices"},{"location":"2_containerization/containers/#performance-best-practices","text":"Layer Caching : Order Containerfile instructions to maximize cache hits Multi-stage Builds : Separate build and runtime environments Minimize Layers : Combine RUN commands when logical .containerignore : Exclude unnecessary files from build context Example .containerignore : node_modules .git * .md .gitignore Containerfile * * .log","title":"Performance Best Practices"},{"location":"2_containerization/containers/#development-workflow","text":"Local Development : Use volume mounts for hot reloading Testing : Create separate images for testing environments Debugging : Use interactive shells for troubleshooting # Interactive debugging session podman run -it --rm myimage /bin/bash # Run with development volume mounts podman run -d \\ -v $( pwd ) :/app:Z \\ -p 5000 :5000 \\ --name dev-container \\ myapi:dev","title":"Development Workflow"},{"location":"2_containerization/containers/#tools-and-resources","text":"","title":"Tools and Resources"},{"location":"2_containerization/containers/#essential-podman-commands","text":"# Image management podman images # List images podman pull image:tag # Pull image podman rmi image:tag # Remove image podman build -t name:tag . # Build image # Container management podman ps # List running containers podman ps -a # List all containers podman run [ options ] image # Run container podman stop container # Stop container podman rm container # Remove container # Networking podman network ls # List networks podman network create name # Create network podman port container # Show port mappings # Troubleshooting podman logs container # View logs podman exec -it container bash # Interactive shell podman inspect container # Detailed information","title":"Essential Podman Commands"},{"location":"2_containerization/containers/#useful-resources","text":"Podman Official Documentation Red Hat UBI Images Container Best Practices Rootless Containers Guide","title":"Useful Resources"},{"location":"2_containerization/containers/#hands-on-exercise","text":"","title":"Hands-on Exercise"},{"location":"2_containerization/containers/#exercise-containerize-a-full-stack-application","text":"Create a multi-container application with: 1. .NET Web API backend 2. React frontend 3. PostgreSQL database Requirements : - Use only Red Hat UBI base images - Implement proper security practices (non-root users) - Use Podman networks for container communication - Include proper error handling and logging - Create a podman compose  file for orchestration Steps : Create the .NET API with Entity Framework Create a React frontend that consumes the API Set up PostgreSQL with proper initialization Create Containerfiles for each component Create a compose.yml file Test the complete application stack Deliverables : - Working containerized application - Documentation of the containerization process - Security analysis of the implementation - Performance testing results","title":"Exercise: Containerize a Full-Stack Application"},{"location":"2_containerization/containers/#summary","text":"Container fundamentals with Podman provide the foundation for modern application development and deployment. Key takeaways include: Podman offers enhanced security through rootless containers and daemonless architecture Red Hat UBI images provide enterprise-grade security and compliance Proper security practices include non-root users and minimal base images Multi-stage builds optimize image size and security Container orchestration enables complex application architectures Development workflows benefit from containerization through consistency and portability By mastering these container fundamentals, developers can build secure, scalable, and maintainable applications that follow modern DevOps practices and integrate seamlessly with cloud-native architectures.","title":"Summary"},{"location":"2_containerization/k8s_openshift/","text":"","title":"Kubernetes & OpenShift"},{"location":"3_foundations/12_factor_app/","text":"","title":"12-Factor App Methodology"},{"location":"3_foundations/microservices/","text":"","title":"Microservices Architecture"},{"location":"3_foundations/nfrs/","text":"","title":"Non-Functional Requirements"},{"location":"3_foundations/open_practices_inner_loop/","text":"","title":"Inner Loop Practices"},{"location":"3_foundations/open_practices_outer_loop/","text":"","title":"Outer Loop Practices"},{"location":"3_foundations/requirement_centric_development/","text":"","title":"Requirement-Centric Development"},{"location":"4_testing/bdd_tdd/","text":"BDD and TDD Practices \u00b6 Overview \u00b6 Behavior-Driven Development (BDD) and Test-Driven Development (TDD) are fundamental practices for modern software development that ensure code quality, maintainability, and alignment with business requirements. This guide provides practical guidance for junior and mid-senior developers working with .NET and React Native applications, demonstrating these practices using Podman containers and Red Hat UBI images. BDD focuses on defining application behavior through collaboration between developers, testers, and business stakeholders, while TDD emphasizes writing tests before implementation code. Together, they create a robust development workflow that produces reliable, well-documented software. Key Concepts \u00b6 Test-Driven Development (TDD) \u00b6 TDD follows the \"Red-Green-Refactor\" cycle: Red : Write a failing test that defines desired functionality Green : Write minimal code to make the test pass Refactor : Improve code quality while maintaining test coverage Behavior-Driven Development (BDD) \u00b6 BDD extends TDD by: - Using natural language to describe behavior - Focusing on business value and user outcomes - Encouraging collaboration between technical and non-technical stakeholders - Following Given-When-Then syntax for scenarios Key Benefits \u00b6 Early Bug Detection : Issues are caught during development, not after deployment Living Documentation : Tests serve as executable specifications Design Improvement : Test-first approach leads to better code architecture Confidence in Changes : Comprehensive test coverage enables safe refactoring Business Alignment : BDD ensures features meet actual business needs Prerequisites \u00b6 .NET 6+ SDK and Entity Framework knowledge React Native and TypeScript familiarity Basic understanding of testing concepts Podman installed and configured Access to Red Hat UBI container images Required Testing Frameworks \u00b6 .NET Stack: - xUnit for unit testing - SpecFlow for BDD scenarios - Moq for mocking - Testcontainers for integration testing React Native Stack: - Jest for unit testing - React Native Testing Library - Cucumber.js for BDD scenarios - MSW (Mock Service Worker) for API mocking Practical Examples \u00b6 Example 1: TDD with .NET Web API \u00b6 Let's implement a product catalog API using TDD principles. Step 1: Set Up the Testing Environment \u00b6 Create a new .NET solution with test project: mkdir ProductCatalog cd ProductCatalog dotnet new sln dotnet new webapi -n ProductCatalog.Api dotnet new xunit -n ProductCatalog.Tests dotnet sln add ProductCatalog.Api ProductCatalog.Tests Add required testing packages: cd ProductCatalog.Tests dotnet add package Moq dotnet add package Microsoft.AspNetCore.Mvc.Testing dotnet add package Testcontainers.PostgreSql Step 2: Write Failing Test (Red Phase) \u00b6 // ProductCatalog.Tests/Controllers/ProductsControllerTests.cs using Xunit ; using Moq ; using Microsoft.AspNetCore.Mvc ; using ProductCatalog.Api.Controllers ; using ProductCatalog.Api.Models ; using ProductCatalog.Api.Services ; namespace ProductCatalog.Tests.Controllers { public class ProductsControllerTests { private readonly Mock < IProductService > _mockProductService ; private readonly ProductsController _controller ; public ProductsControllerTests () { _mockProductService = new Mock < IProductService > (); _controller = new ProductsController ( _mockProductService . Object ); } [Fact] public async Task GetProducts_ReturnsOkResult_WithListOfProducts () { // Arrange var expectedProducts = new List < Product > { new Product { Id = 1 , Name = \"Laptop\" , Price = 999.99m }, new Product { Id = 2 , Name = \"Mouse\" , Price = 29.99m } }; _mockProductService . Setup ( service => service . GetAllProductsAsync ()) . ReturnsAsync ( expectedProducts ); // Act var result = await _controller . GetProducts (); // Assert var okResult = Assert . IsType < OkObjectResult > ( result . Result ); var products = Assert . IsType < List < Product >> ( okResult . Value ); Assert . Equal ( 2 , products . Count ); Assert . Equal ( \"Laptop\" , products [ 0 ]. Name ); } [Fact] public async Task CreateProduct_WithValidProduct_ReturnsCreatedResult () { // Arrange var newProduct = new CreateProductRequest { Name = \"Keyboard\" , Price = 79.99m , Description = \"Mechanical keyboard\" }; var createdProduct = new Product { Id = 3 , Name = newProduct . Name , Price = newProduct . Price , Description = newProduct . Description }; _mockProductService . Setup ( service => service . CreateProductAsync ( It . IsAny < CreateProductRequest > ())) . ReturnsAsync ( createdProduct ); // Act var result = await _controller . CreateProduct ( newProduct ); // Assert var createdResult = Assert . IsType < CreatedAtActionResult > ( result . Result ); var product = Assert . IsType < Product > ( createdResult . Value ); Assert . Equal ( \"Keyboard\" , product . Name ); Assert . Equal ( 79.99m , product . Price ); } } } Step 3: Make Tests Pass (Green Phase) \u00b6 Create the minimal implementation: // ProductCatalog.Api/Models/Product.cs namespace ProductCatalog.Api.Models { public class Product { public int Id { get ; set ; } public string Name { get ; set ; } = string . Empty ; public decimal Price { get ; set ; } public string Description { get ; set ; } = string . Empty ; public DateTime CreatedAt { get ; set ; } = DateTime . UtcNow ; } public class CreateProductRequest { public string Name { get ; set ; } = string . Empty ; public decimal Price { get ; set ; } public string Description { get ; set ; } = string . Empty ; } } // ProductCatalog.Api/Services/IProductService.cs using ProductCatalog.Api.Models ; namespace ProductCatalog.Api.Services { public interface IProductService { Task < IEnumerable < Product >> GetAllProductsAsync (); Task < Product ?> GetProductByIdAsync ( int id ); Task < Product > CreateProductAsync ( CreateProductRequest request ); Task < Product ?> UpdateProductAsync ( int id , CreateProductRequest request ); Task < bool > DeleteProductAsync ( int id ); } } // ProductCatalog.Api/Controllers/ProductsController.cs using Microsoft.AspNetCore.Mvc ; using ProductCatalog.Api.Models ; using ProductCatalog.Api.Services ; namespace ProductCatalog.Api.Controllers { [ApiController] [Route(\"api/[controller] \")] public class ProductsController : ControllerBase { private readonly IProductService _productService ; private readonly ILogger < ProductsController > _logger ; public ProductsController ( IProductService productService , ILogger < ProductsController > logger ) { _productService = productService ; _logger = logger ; } [HttpGet] public async Task < ActionResult < IEnumerable < Product >>> GetProducts () { try { var products = await _productService . GetAllProductsAsync (); return Ok ( products ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error retrieving products\" ); return StatusCode ( 500 , \"Internal server error\" ); } } [HttpPost] public async Task < ActionResult < Product >> CreateProduct ( CreateProductRequest request ) { try { if ( ! ModelState . IsValid ) { return BadRequest ( ModelState ); } var product = await _productService . CreateProductAsync ( request ); return CreatedAtAction ( nameof ( GetProductById ), new { id = product . Id }, product ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error creating product\" ); return StatusCode ( 500 , \"Internal server error\" ); } } [HttpGet(\"{id}\")] public async Task < ActionResult < Product >> GetProductById ( int id ) { try { var product = await _productService . GetProductByIdAsync ( id ); if ( product == null ) { return NotFound (); } return Ok ( product ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error retrieving product {ProductId}\" , id ); return StatusCode ( 500 , \"Internal server error\" ); } } } } Step 4: Refactor and Improve \u00b6 Add validation and improve error handling: // ProductCatalog.Api/Models/CreateProductRequest.cs using System.ComponentModel.DataAnnotations ; namespace ProductCatalog.Api.Models { public class CreateProductRequest { [Required(ErrorMessage = \"Product name is required\")] [StringLength(100, ErrorMessage = \"Product name cannot exceed 100 characters\")] public string Name { get ; set ; } = string . Empty ; [Required(ErrorMessage = \"Price is required\")] [Range(0.01, double.MaxValue, ErrorMessage = \"Price must be greater than 0\")] public decimal Price { get ; set ; } [StringLength(500, ErrorMessage = \"Description cannot exceed 500 characters\")] public string Description { get ; set ; } = string . Empty ; } } Example 2: BDD with SpecFlow (.NET) \u00b6 Let's implement BDD scenarios for the product catalog. Step 1: Set Up SpecFlow \u00b6 cd ProductCatalog.Tests dotnet add package SpecFlow.xUnit dotnet add package SpecFlow.Tools.MsBuild.Generation Step 2: Create Feature File \u00b6 # ProductCatalog.Tests/Features/ProductManagement.feature Feature: Product Management As a store manager I want to manage products in the catalog So that customers can browse and purchase items Background: Given the product catalog service is available And the database is clean Scenario: Create a new product successfully Given I have valid product details: | Name | Price | Description | | Laptop | 999.99 | Gaming laptop | When I create the product Then the product should be created successfully And the product should have an ID And the product should be retrievable by ID Scenario: Retrieve all products Given the following products exist: | Name | Price | Description | | Laptop | 999.99 | Gaming laptop | | Mouse | 29.99 | Wireless mouse | | Keyboard | 79.99 | Mechanical keyboard | When I request all products Then I should receive 3 products And the products should be ordered by creation date Scenario: Create product with invalid data fails Given I have invalid product details: | Name | Price | Description | | | -10 | Too long description that exceeds the maximum allowed length of 500 characters... | When I attempt to create the product Then the creation should fail with validation errors And I should receive appropriate error messages Scenario: Update existing product Given a product exists with: | Name | Price | Description | | Laptop | 999.99 | Gaming laptop | When I update the product with: | Name | Price | Description | | Gaming Laptop | 1199.99 | High-end laptop | Then the product should be updated successfully And the updated product should be retrievable Step 3: Implement Step Definitions \u00b6 // ProductCatalog.Tests/StepDefinitions/ProductManagementSteps.cs using TechTalk.SpecFlow ; using TechTalk.SpecFlow.Assist ; using Xunit ; using Microsoft.AspNetCore.Mvc.Testing ; using Microsoft.Extensions.DependencyInjection ; using ProductCatalog.Api ; using ProductCatalog.Api.Models ; using System.Net.Http.Json ; using System.Net ; namespace ProductCatalog.Tests.StepDefinitions { [Binding] public class ProductManagementSteps : IClassFixture < WebApplicationFactory < Program >> { private readonly WebApplicationFactory < Program > _factory ; private readonly HttpClient _client ; private readonly ScenarioContext _scenarioContext ; private CreateProductRequest ? _productRequest ; private HttpResponseMessage ? _response ; private Product ? _createdProduct ; private List < Product >? _retrievedProducts ; public ProductManagementSteps ( WebApplicationFactory < Program > factory , ScenarioContext scenarioContext ) { _factory = factory ; _scenarioContext = scenarioContext ; _client = _factory . CreateClient (); } [Given(@\"the product catalog service is available\")] public void GivenTheProductCatalogServiceIsAvailable () { // Verify the service is running var response = _client . GetAsync ( \"/health\" ). Result ; Assert . True ( response . IsSuccessStatusCode ); } [Given(@\"the database is clean\")] public async Task GivenTheDatabaseIsClean () { // Clean database for test isolation using var scope = _factory . Services . CreateScope (); var context = scope . ServiceProvider . GetRequiredService < ProductDbContext > (); context . Products . RemoveRange ( context . Products ); await context . SaveChangesAsync (); } [Given(@\"I have valid product details:\")] public void GivenIHaveValidProductDetails ( Table table ) { _productRequest = table . CreateInstance < CreateProductRequest > (); } [Given(@\"I have invalid product details:\")] public void GivenIHaveInvalidProductDetails ( Table table ) { _productRequest = table . CreateInstance < CreateProductRequest > (); } [Given(@\"the following products exist:\")] public async Task GivenTheFollowingProductsExist ( Table table ) { var products = table . CreateSet < CreateProductRequest > (); foreach ( var product in products ) { var response = await _client . PostAsJsonAsync ( \"/api/products\" , product ); Assert . True ( response . IsSuccessStatusCode ); } } [Given(@\"a product exists with:\")] public async Task GivenAProductExistsWith ( Table table ) { _productRequest = table . CreateInstance < CreateProductRequest > (); _response = await _client . PostAsJsonAsync ( \"/api/products\" , _productRequest ); _createdProduct = await _response . Content . ReadFromJsonAsync < Product > (); _scenarioContext [ \"ExistingProduct\" ] = _createdProduct ; } [When(@\"I create the product\")] public async Task WhenICreateTheProduct () { _response = await _client . PostAsJsonAsync ( \"/api/products\" , _productRequest ); if ( _response . IsSuccessStatusCode ) { _createdProduct = await _response . Content . ReadFromJsonAsync < Product > (); } } [When(@\"I attempt to create the product\")] public async Task WhenIAttemptToCreateTheProduct () { _response = await _client . PostAsJsonAsync ( \"/api/products\" , _productRequest ); } [When(@\"I request all products\")] public async Task WhenIRequestAllProducts () { _response = await _client . GetAsync ( \"/api/products\" ); if ( _response . IsSuccessStatusCode ) { _retrievedProducts = await _response . Content . ReadFromJsonAsync < List < Product >> (); } } [When(@\"I update the product with:\")] public async Task WhenIUpdateTheProductWith ( Table table ) { var existingProduct = _scenarioContext [ \"ExistingProduct\" ] as Product ; var updateRequest = table . CreateInstance < CreateProductRequest > (); _response = await _client . PutAsJsonAsync ( $\"/api/products/{existingProduct!.Id}\" , updateRequest ); if ( _response . IsSuccessStatusCode ) { _createdProduct = await _response . Content . ReadFromJsonAsync < Product > (); } } [Then(@\"the product should be created successfully\")] public void ThenTheProductShouldBeCreatedSuccessfully () { Assert . Equal ( HttpStatusCode . Created , _response ! . StatusCode ); Assert . NotNull ( _createdProduct ); } [Then(@\"the product should have an ID\")] public void ThenTheProductShouldHaveAnId () { Assert . True ( _createdProduct ! . Id > 0 ); } [Then(@\"the product should be retrievable by ID\")] public async Task ThenTheProductShouldBeRetrievableById () { var response = await _client . GetAsync ( $\"/api/products/{_createdProduct!.Id}\" ); Assert . True ( response . IsSuccessStatusCode ); var retrievedProduct = await response . Content . ReadFromJsonAsync < Product > (); Assert . Equal ( _createdProduct . Name , retrievedProduct ! . Name ); Assert . Equal ( _createdProduct . Price , retrievedProduct . Price ); } [Then(@\"I should receive (.*) products\")] public void ThenIShouldReceiveProducts ( int expectedCount ) { Assert . Equal ( HttpStatusCode . OK , _response ! . StatusCode ); Assert . NotNull ( _retrievedProducts ); Assert . Equal ( expectedCount , _retrievedProducts . Count ); } [Then(@\"the products should be ordered by creation date\")] public void ThenTheProductsShouldBeOrderedByCreationDate () { for ( int i = 1 ; i < _retrievedProducts ! . Count ; i ++ ) { Assert . True ( _retrievedProducts [ i - 1 ]. CreatedAt <= _retrievedProducts [ i ]. CreatedAt ); } } [Then(@\"the creation should fail with validation errors\")] public void ThenTheCreationShouldFailWithValidationErrors () { Assert . Equal ( HttpStatusCode . BadRequest , _response ! . StatusCode ); } [Then(@\"I should receive appropriate error messages\")] public async Task ThenIShouldReceiveAppropriateErrorMessages () { var errorContent = await _response ! . Content . ReadAsStringAsync (); Assert . Contains ( \"validation\" , errorContent . ToLower ()); } [Then(@\"the product should be updated successfully\")] public void ThenTheProductShouldBeUpdatedSuccessfully () { Assert . Equal ( HttpStatusCode . OK , _response ! . StatusCode ); Assert . NotNull ( _createdProduct ); } [Then(@\"the updated product should be retrievable\")] public async Task ThenTheUpdatedProductShouldBeRetrievable () { var response = await _client . GetAsync ( $\"/api/products/{_createdProduct!.Id}\" ); Assert . True ( response . IsSuccessStatusCode ); } } } Example 3: TDD with React Native \u00b6 Let's implement TDD for a React Native product list component. Step 1: Set Up Testing Environment \u00b6 npx react-native init ProductCatalogApp --template react-native-template-typescript cd ProductCatalogApp npm install --save-dev @testing-library/react-native @testing-library/jest-native Step 2: Write Failing Test \u00b6 // __tests__/components/ProductList.test.tsx import React from 'react' ; import { render , screen , waitFor } from '@testing-library/react-native' ; import { ProductList } from '../../src/components/ProductList' ; import { Product } from '../../src/types/Product' ; // Mock the fetch function global . fetch = jest . fn (); describe ( 'ProductList' , () => { beforeEach (() => { jest . clearAllMocks (); }); it ( 'displays loading indicator while fetching products' , () => { // Arrange ( fetch as jest . Mock ). mockResolvedValueOnce ({ ok : true , json : () => Promise . resolve ([]), }); // Act render ( < ProductList /> ); // Assert expect ( screen . getByTestId ( 'loading-indicator' )). toBeTruthy (); }); it ( 'displays products when fetch is successful' , async () => { // Arrange const mockProducts : Product [] = [ { id : 1 , name : 'Laptop' , price : 999.99 , description : 'Gaming laptop' }, { id : 2 , name : 'Mouse' , price : 29.99 , description : 'Wireless mouse' }, ]; ( fetch as jest . Mock ). mockResolvedValueOnce ({ ok : true , json : () => Promise . resolve ( mockProducts ), }); // Act render ( < ProductList /> ); // Assert await waitFor (() => { expect ( screen . getByText ( 'Laptop' )). toBeTruthy (); expect ( screen . getByText ( '$999.99' )). toBeTruthy (); expect ( screen . getByText ( 'Mouse' )). toBeTruthy (); expect ( screen . getByText ( '$29.99' )). toBeTruthy (); }); }); it ( 'displays error message when fetch fails' , async () => { // Arrange ( fetch as jest . Mock ). mockRejectedValueOnce ( new Error ( 'Network error' )); // Act render ( < ProductList /> ); // Assert await waitFor (() => { expect ( screen . getByText ( 'Error loading products' )). toBeTruthy (); }); }); it ( 'calls fetch with correct URL' , () => { // Arrange & Act render ( < ProductList /> ); // Assert expect ( fetch ). toHaveBeenCalledWith ( 'https://api.example.com/products' ); }); }); Step 3: Implement Component (Green Phase) \u00b6 // src/types/Product.ts export interface Product { id : number ; name : string ; price : number ; description : string ; } // src/components/ProductList.tsx import React , { useEffect , useState } from 'react' ; import { View , Text , FlatList , ActivityIndicator , StyleSheet , Alert , } from 'react-native' ; import { Product } from '../types/Product' ; export const ProductList : React.FC = () => { const [ products , setProducts ] = useState < Product [] > ([]); const [ loading , setLoading ] = useState ( true ); const [ error , setError ] = useState < string | null > ( null ); useEffect (() => { fetchProducts (); }, []); const fetchProducts = async () => { try { setLoading ( true ); setError ( null ); const response = await fetch ( 'https://api.example.com/products' ); if ( ! response . ok ) { throw new Error ( `HTTP error! status: ${ response . status } ` ); } const data = await response . json (); setProducts ( data ); } catch ( err ) { const errorMessage = err instanceof Error ? err . message : 'Unknown error' ; setError ( 'Error loading products' ); console . error ( 'Error fetching products:' , errorMessage ); } finally { setLoading ( false ); } }; const renderProduct = ({ item } : { item : Product }) => ( < View style = { styles . productItem } > < Text style = { styles . productName } > { item . name } < /Text> < Text style = { styles . productPrice } > $ { item . price . toFixed ( 2 )} < /Text> < Text style = { styles . productDescription } > { item . description } < /Text> < /View> ); if ( loading ) { return ( < View style = { styles . centerContainer } > < ActivityIndicator testID = \"loading-indicator\" size = \"large\" color = \"#0000ff\" /> < Text > Loading products ... < /Text> < /View> ); } if ( error ) { return ( < View style = { styles . centerContainer } > < Text style = { styles . errorText } > { error } < /Text> < /View> ); } return ( < FlatList data = { products } renderItem = { renderProduct } keyExtractor = {( item ) => item . id . toString ()} style = { styles . container } testID = \"product-list\" /> ); }; const styles = StyleSheet . create ({ container : { flex : 1 , backgroundColor : '#f5f5f5' , }, centerContainer : { flex : 1 , justifyContent : 'center' , alignItems : 'center' , padding : 20 , }, productItem : { backgroundColor : 'white' , padding : 16 , marginHorizontal : 16 , marginVertical : 8 , borderRadius : 8 , shadowColor : '#000' , shadowOffset : { width : 0 , height : 2 }, shadowOpacity : 0.1 , shadowRadius : 4 , elevation : 3 , }, productName : { fontSize : 18 , fontWeight : 'bold' , marginBottom : 4 , }, productPrice : { fontSize : 16 , color : '#007AFF' , fontWeight : '600' , marginBottom : 4 , }, productDescription : { fontSize : 14 , color : '#666' , }, errorText : { color : 'red' , fontSize : 16 , textAlign : 'center' , }, }); Common Pitfalls \u00b6 1. Writing Tests After Implementation \u00b6 Problem : Writing tests after code is implemented reduces their effectiveness and may lead to tests that confirm existing bugs. Solution : Always write tests first (Red phase) to ensure tests actually validate the intended behavior: // BAD: Testing existing implementation it ( 'should do what the current code does' , () => { const result = existingFunction (); expect ( result ). toBe ( whatever_it_currently_returns ); }); // GOOD: Testing intended behavior it ( 'should calculate total price including tax' , () => { const order = new Order ([ { price : 100 , quantity : 2 }, { price : 50 , quantity : 1 } ]); const total = order . calculateTotalWithTax ( 0.1 ); // 10% tax expect ( total ). toBe ( 275 ); // (200 + 50) * 1.1 }); 2. Over-Mocking in Tests \u00b6 Problem : Excessive mocking can make tests brittle and reduce confidence in the system. Solution : Use mocks judiciously and prefer integration tests where appropriate: // BAD: Over-mocking [Fact] public void CalculateTotal_ShouldReturnCorrectValue () { var mockItem1 = new Mock < IOrderItem > (); mockItem1 . Setup ( x => x . GetPrice ()). Returns ( 10 ); var mockItem2 = new Mock < IOrderItem > (); mockItem2 . Setup ( x => x . GetPrice ()). Returns ( 20 ); var order = new Order (); order . AddItem ( mockItem1 . Object ); order . AddItem ( mockItem2 . Object ); Assert . Equal ( 30 , order . CalculateTotal ()); } // GOOD: Testing with real objects [Fact] public void CalculateTotal_WithRealItems_ReturnsCorrectValue () { var order = new Order (); order . AddItem ( new OrderItem ( \"Product1\" , 10 , 1 )); order . AddItem ( new OrderItem ( \"Product2\" , 20 , 1 )); Assert . Equal ( 30 , order . CalculateTotal ()); } 3. Poor BDD Scenario Writing \u00b6 Problem : BDD scenarios that are too technical or don't reflect real user behavior. Solution : Write scenarios from the user's perspective using business language: # BAD: Too technical Scenario: POST request to /api/products returns 201 Given I send a POST request to /api/products When the request contains valid JSON Then the response should be 201 And the Location header should be set # GOOD: Business-focused Scenario: Store manager adds new product to catalog Given I am logged in as a store manager When I add a new product \" Gaming Laptop \" priced at $ 1299.99 Then the product should appear in the catalog And customers should be able to find it by searching 4. Ignoring Test Performance \u00b6 Problem : Slow tests discourage running them frequently, reducing their value. Solution : Use appropriate test isolation and consider test containers for integration tests: # docker-compose.test.yml for fast test database version : '3.8' services : test-db : image : registry.access.redhat.com/rhel8/postgresql-13 environment : POSTGRESQL_DATABASE : testdb POSTGRESQL_USER : testuser POSTGRESQL_PASSWORD : testpass ports : - \"5433:5432\" tmpfs : - /var/lib/postgresql/data # In-memory for speed Best Practices \u00b6 TDD Best Practices \u00b6 Start with the simplest test : Begin with basic scenarios before edge cases Write minimal code to pass : Don't over-engineer in the Green phase Refactor regularly : Improve code quality after tests pass Test behavior, not implementation : Focus on what the code should do, not how Use descriptive test names : Make test intent clear from the name // Good test naming conventions [Fact] public void CalculateDiscount_WithValidCustomerAndAmount_ReturnsCorrectDiscount () [Fact] public void CalculateDiscount_WithInvalidAmount_ThrowsArgumentException () [Fact] public void CalculateDiscount_WithNullCustomer_ThrowsArgumentNullException () BDD Best Practices \u00b6 Collaborate on scenarios : Include stakeholders in scenario writing Use ubiquitous language : Use domain terms consistently Keep scenarios focused : One behavior per scenario Use data tables effectively : For parameterized scenarios Maintain living documentation : Keep scenarios updated with code changes # Example of focused, business-oriented scenario Scenario: Customer receives loyalty discount Given I am a loyalty customer with \" Gold \" status And I have an order worth $ 200 When I apply my loyalty discount Then I should receive a 15 % discount And my final total should be $ 170 Integration with Containers \u00b6 Use Testcontainers : For realistic integration tests Isolate test databases : Each test run should use clean data Container health checks : Ensure services are ready before testing Resource cleanup : Properly dispose of containers after tests // Example using Testcontainers with PostgreSQL public class ProductServiceIntegrationTests : IAsyncLifetime { private readonly PostgreSqlContainer _postgres = new PostgreSqlBuilder () . WithImage ( \"registry.access.redhat.com/rhel8/postgresql-13\" ) . WithDatabase ( \"testdb\" ) . WithUsername ( \"testuser\" ) . WithPassword ( \"testpass\" ) . Build (); public async Task InitializeAsync () { await _postgres . StartAsync (); } public async Task DisposeAsync () { await _postgres . DisposeAsync (); } } Tools and Resources \u00b6 .NET Testing Tools \u00b6 xUnit : Modern testing framework for .NET SpecFlow : BDD framework for .NET Moq : Mocking framework Testcontainers : Integration testing with containers Coverlet : Code coverage analysis ReportGenerator : Coverage report generation React Native Testing Tools \u00b6 Jest : JavaScript testing framework React Native Testing Library : Component testing utilities Cucumber.js : BDD framework for JavaScript MSW : API mocking for testing Detox : End-to-end testing for React Native Container Testing Setup \u00b6 # Containerfile.test - Testing environment with UBI FROM registry.access.redhat.com/ubi8/dotnet-60 WORKDIR /app # Install development tools RUN dnf install -y git # Copy test projects COPY *.Tests/*.csproj ./Tests/ COPY *.Api/*.csproj ./Api/ # Restore dependencies RUN dotnet restore Tests/ && dotnet restore Api/ # Copy source code COPY . . # Run tests CMD [ \"dotnet\" , \"test\" , \"Tests/\" , \"--logger\" , \"trx\" , \"--results-directory\" , \"/app/TestResults\" ] Useful Resources \u00b6 xUnit Documentation SpecFlow Documentation React Native Testing Library Testcontainers Documentation BDD Best Practices Hands-on Exercise \u00b6 Exercise: Complete E-commerce Testing Suite \u00b6 Implement a comprehensive testing suite for an e-commerce application using both TDD and BDD approaches. Requirements: Backend (.NET API): Product catalog management Shopping cart functionality Order processing User authentication Frontend (React Native): Product browsing Cart management Checkout process User profile Testing Requirements: Unit tests with 90%+ coverage BDD scenarios for key user journeys Integration tests using Testcontainers End-to-end tests for critical paths Performance tests for API endpoints Deliverables: Complete test suite with documentation BDD feature files with business scenarios Containerized testing environment CI/CD pipeline configuration for automated testing Test reporting and coverage analysis Evaluation Criteria: Test coverage and quality BDD scenario clarity and business alignment Integration test effectiveness Performance test results Documentation quality Summary \u00b6 BDD and TDD practices form the foundation of quality software development by ensuring code correctness, maintainability, and business alignment. Key takeaways include: TDD improves design through the Red-Green-Refactor cycle BDD ensures business alignment through collaborative scenario development Test-first development catches bugs early and reduces costs Comprehensive testing includes unit, integration, and end-to-end tests Container-based testing provides realistic and isolated test environments Living documentation through tests maintains system knowledge Continuous testing in CI/CD pipelines ensures ongoing quality By implementing these practices with .NET and React Native applications using Podman and Red Hat UBI images, development teams can deliver reliable, well-tested software that meets both technical and business requirements. The combination of TDD and BDD creates a robust development workflow that scales from individual developers to large enterprise teams.","title":"BDD and TDD Practices"},{"location":"4_testing/bdd_tdd/#bdd-and-tdd-practices","text":"","title":"BDD and TDD Practices"},{"location":"4_testing/bdd_tdd/#overview","text":"Behavior-Driven Development (BDD) and Test-Driven Development (TDD) are fundamental practices for modern software development that ensure code quality, maintainability, and alignment with business requirements. This guide provides practical guidance for junior and mid-senior developers working with .NET and React Native applications, demonstrating these practices using Podman containers and Red Hat UBI images. BDD focuses on defining application behavior through collaboration between developers, testers, and business stakeholders, while TDD emphasizes writing tests before implementation code. Together, they create a robust development workflow that produces reliable, well-documented software.","title":"Overview"},{"location":"4_testing/bdd_tdd/#key-concepts","text":"","title":"Key Concepts"},{"location":"4_testing/bdd_tdd/#test-driven-development-tdd","text":"TDD follows the \"Red-Green-Refactor\" cycle: Red : Write a failing test that defines desired functionality Green : Write minimal code to make the test pass Refactor : Improve code quality while maintaining test coverage","title":"Test-Driven Development (TDD)"},{"location":"4_testing/bdd_tdd/#behavior-driven-development-bdd","text":"BDD extends TDD by: - Using natural language to describe behavior - Focusing on business value and user outcomes - Encouraging collaboration between technical and non-technical stakeholders - Following Given-When-Then syntax for scenarios","title":"Behavior-Driven Development (BDD)"},{"location":"4_testing/bdd_tdd/#key-benefits","text":"Early Bug Detection : Issues are caught during development, not after deployment Living Documentation : Tests serve as executable specifications Design Improvement : Test-first approach leads to better code architecture Confidence in Changes : Comprehensive test coverage enables safe refactoring Business Alignment : BDD ensures features meet actual business needs","title":"Key Benefits"},{"location":"4_testing/bdd_tdd/#prerequisites","text":".NET 6+ SDK and Entity Framework knowledge React Native and TypeScript familiarity Basic understanding of testing concepts Podman installed and configured Access to Red Hat UBI container images","title":"Prerequisites"},{"location":"4_testing/bdd_tdd/#required-testing-frameworks","text":".NET Stack: - xUnit for unit testing - SpecFlow for BDD scenarios - Moq for mocking - Testcontainers for integration testing React Native Stack: - Jest for unit testing - React Native Testing Library - Cucumber.js for BDD scenarios - MSW (Mock Service Worker) for API mocking","title":"Required Testing Frameworks"},{"location":"4_testing/bdd_tdd/#practical-examples","text":"","title":"Practical Examples"},{"location":"4_testing/bdd_tdd/#example-1-tdd-with-net-web-api","text":"Let's implement a product catalog API using TDD principles.","title":"Example 1: TDD with .NET Web API"},{"location":"4_testing/bdd_tdd/#step-1-set-up-the-testing-environment","text":"Create a new .NET solution with test project: mkdir ProductCatalog cd ProductCatalog dotnet new sln dotnet new webapi -n ProductCatalog.Api dotnet new xunit -n ProductCatalog.Tests dotnet sln add ProductCatalog.Api ProductCatalog.Tests Add required testing packages: cd ProductCatalog.Tests dotnet add package Moq dotnet add package Microsoft.AspNetCore.Mvc.Testing dotnet add package Testcontainers.PostgreSql","title":"Step 1: Set Up the Testing Environment"},{"location":"4_testing/bdd_tdd/#step-2-write-failing-test-red-phase","text":"// ProductCatalog.Tests/Controllers/ProductsControllerTests.cs using Xunit ; using Moq ; using Microsoft.AspNetCore.Mvc ; using ProductCatalog.Api.Controllers ; using ProductCatalog.Api.Models ; using ProductCatalog.Api.Services ; namespace ProductCatalog.Tests.Controllers { public class ProductsControllerTests { private readonly Mock < IProductService > _mockProductService ; private readonly ProductsController _controller ; public ProductsControllerTests () { _mockProductService = new Mock < IProductService > (); _controller = new ProductsController ( _mockProductService . Object ); } [Fact] public async Task GetProducts_ReturnsOkResult_WithListOfProducts () { // Arrange var expectedProducts = new List < Product > { new Product { Id = 1 , Name = \"Laptop\" , Price = 999.99m }, new Product { Id = 2 , Name = \"Mouse\" , Price = 29.99m } }; _mockProductService . Setup ( service => service . GetAllProductsAsync ()) . ReturnsAsync ( expectedProducts ); // Act var result = await _controller . GetProducts (); // Assert var okResult = Assert . IsType < OkObjectResult > ( result . Result ); var products = Assert . IsType < List < Product >> ( okResult . Value ); Assert . Equal ( 2 , products . Count ); Assert . Equal ( \"Laptop\" , products [ 0 ]. Name ); } [Fact] public async Task CreateProduct_WithValidProduct_ReturnsCreatedResult () { // Arrange var newProduct = new CreateProductRequest { Name = \"Keyboard\" , Price = 79.99m , Description = \"Mechanical keyboard\" }; var createdProduct = new Product { Id = 3 , Name = newProduct . Name , Price = newProduct . Price , Description = newProduct . Description }; _mockProductService . Setup ( service => service . CreateProductAsync ( It . IsAny < CreateProductRequest > ())) . ReturnsAsync ( createdProduct ); // Act var result = await _controller . CreateProduct ( newProduct ); // Assert var createdResult = Assert . IsType < CreatedAtActionResult > ( result . Result ); var product = Assert . IsType < Product > ( createdResult . Value ); Assert . Equal ( \"Keyboard\" , product . Name ); Assert . Equal ( 79.99m , product . Price ); } } }","title":"Step 2: Write Failing Test (Red Phase)"},{"location":"4_testing/bdd_tdd/#step-3-make-tests-pass-green-phase","text":"Create the minimal implementation: // ProductCatalog.Api/Models/Product.cs namespace ProductCatalog.Api.Models { public class Product { public int Id { get ; set ; } public string Name { get ; set ; } = string . Empty ; public decimal Price { get ; set ; } public string Description { get ; set ; } = string . Empty ; public DateTime CreatedAt { get ; set ; } = DateTime . UtcNow ; } public class CreateProductRequest { public string Name { get ; set ; } = string . Empty ; public decimal Price { get ; set ; } public string Description { get ; set ; } = string . Empty ; } } // ProductCatalog.Api/Services/IProductService.cs using ProductCatalog.Api.Models ; namespace ProductCatalog.Api.Services { public interface IProductService { Task < IEnumerable < Product >> GetAllProductsAsync (); Task < Product ?> GetProductByIdAsync ( int id ); Task < Product > CreateProductAsync ( CreateProductRequest request ); Task < Product ?> UpdateProductAsync ( int id , CreateProductRequest request ); Task < bool > DeleteProductAsync ( int id ); } } // ProductCatalog.Api/Controllers/ProductsController.cs using Microsoft.AspNetCore.Mvc ; using ProductCatalog.Api.Models ; using ProductCatalog.Api.Services ; namespace ProductCatalog.Api.Controllers { [ApiController] [Route(\"api/[controller] \")] public class ProductsController : ControllerBase { private readonly IProductService _productService ; private readonly ILogger < ProductsController > _logger ; public ProductsController ( IProductService productService , ILogger < ProductsController > logger ) { _productService = productService ; _logger = logger ; } [HttpGet] public async Task < ActionResult < IEnumerable < Product >>> GetProducts () { try { var products = await _productService . GetAllProductsAsync (); return Ok ( products ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error retrieving products\" ); return StatusCode ( 500 , \"Internal server error\" ); } } [HttpPost] public async Task < ActionResult < Product >> CreateProduct ( CreateProductRequest request ) { try { if ( ! ModelState . IsValid ) { return BadRequest ( ModelState ); } var product = await _productService . CreateProductAsync ( request ); return CreatedAtAction ( nameof ( GetProductById ), new { id = product . Id }, product ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error creating product\" ); return StatusCode ( 500 , \"Internal server error\" ); } } [HttpGet(\"{id}\")] public async Task < ActionResult < Product >> GetProductById ( int id ) { try { var product = await _productService . GetProductByIdAsync ( id ); if ( product == null ) { return NotFound (); } return Ok ( product ); } catch ( Exception ex ) { _logger . LogError ( ex , \"Error retrieving product {ProductId}\" , id ); return StatusCode ( 500 , \"Internal server error\" ); } } } }","title":"Step 3: Make Tests Pass (Green Phase)"},{"location":"4_testing/bdd_tdd/#step-4-refactor-and-improve","text":"Add validation and improve error handling: // ProductCatalog.Api/Models/CreateProductRequest.cs using System.ComponentModel.DataAnnotations ; namespace ProductCatalog.Api.Models { public class CreateProductRequest { [Required(ErrorMessage = \"Product name is required\")] [StringLength(100, ErrorMessage = \"Product name cannot exceed 100 characters\")] public string Name { get ; set ; } = string . Empty ; [Required(ErrorMessage = \"Price is required\")] [Range(0.01, double.MaxValue, ErrorMessage = \"Price must be greater than 0\")] public decimal Price { get ; set ; } [StringLength(500, ErrorMessage = \"Description cannot exceed 500 characters\")] public string Description { get ; set ; } = string . Empty ; } }","title":"Step 4: Refactor and Improve"},{"location":"4_testing/bdd_tdd/#example-2-bdd-with-specflow-net","text":"Let's implement BDD scenarios for the product catalog.","title":"Example 2: BDD with SpecFlow (.NET)"},{"location":"4_testing/bdd_tdd/#step-1-set-up-specflow","text":"cd ProductCatalog.Tests dotnet add package SpecFlow.xUnit dotnet add package SpecFlow.Tools.MsBuild.Generation","title":"Step 1: Set Up SpecFlow"},{"location":"4_testing/bdd_tdd/#step-2-create-feature-file","text":"# ProductCatalog.Tests/Features/ProductManagement.feature Feature: Product Management As a store manager I want to manage products in the catalog So that customers can browse and purchase items Background: Given the product catalog service is available And the database is clean Scenario: Create a new product successfully Given I have valid product details: | Name | Price | Description | | Laptop | 999.99 | Gaming laptop | When I create the product Then the product should be created successfully And the product should have an ID And the product should be retrievable by ID Scenario: Retrieve all products Given the following products exist: | Name | Price | Description | | Laptop | 999.99 | Gaming laptop | | Mouse | 29.99 | Wireless mouse | | Keyboard | 79.99 | Mechanical keyboard | When I request all products Then I should receive 3 products And the products should be ordered by creation date Scenario: Create product with invalid data fails Given I have invalid product details: | Name | Price | Description | | | -10 | Too long description that exceeds the maximum allowed length of 500 characters... | When I attempt to create the product Then the creation should fail with validation errors And I should receive appropriate error messages Scenario: Update existing product Given a product exists with: | Name | Price | Description | | Laptop | 999.99 | Gaming laptop | When I update the product with: | Name | Price | Description | | Gaming Laptop | 1199.99 | High-end laptop | Then the product should be updated successfully And the updated product should be retrievable","title":"Step 2: Create Feature File"},{"location":"4_testing/bdd_tdd/#step-3-implement-step-definitions","text":"// ProductCatalog.Tests/StepDefinitions/ProductManagementSteps.cs using TechTalk.SpecFlow ; using TechTalk.SpecFlow.Assist ; using Xunit ; using Microsoft.AspNetCore.Mvc.Testing ; using Microsoft.Extensions.DependencyInjection ; using ProductCatalog.Api ; using ProductCatalog.Api.Models ; using System.Net.Http.Json ; using System.Net ; namespace ProductCatalog.Tests.StepDefinitions { [Binding] public class ProductManagementSteps : IClassFixture < WebApplicationFactory < Program >> { private readonly WebApplicationFactory < Program > _factory ; private readonly HttpClient _client ; private readonly ScenarioContext _scenarioContext ; private CreateProductRequest ? _productRequest ; private HttpResponseMessage ? _response ; private Product ? _createdProduct ; private List < Product >? _retrievedProducts ; public ProductManagementSteps ( WebApplicationFactory < Program > factory , ScenarioContext scenarioContext ) { _factory = factory ; _scenarioContext = scenarioContext ; _client = _factory . CreateClient (); } [Given(@\"the product catalog service is available\")] public void GivenTheProductCatalogServiceIsAvailable () { // Verify the service is running var response = _client . GetAsync ( \"/health\" ). Result ; Assert . True ( response . IsSuccessStatusCode ); } [Given(@\"the database is clean\")] public async Task GivenTheDatabaseIsClean () { // Clean database for test isolation using var scope = _factory . Services . CreateScope (); var context = scope . ServiceProvider . GetRequiredService < ProductDbContext > (); context . Products . RemoveRange ( context . Products ); await context . SaveChangesAsync (); } [Given(@\"I have valid product details:\")] public void GivenIHaveValidProductDetails ( Table table ) { _productRequest = table . CreateInstance < CreateProductRequest > (); } [Given(@\"I have invalid product details:\")] public void GivenIHaveInvalidProductDetails ( Table table ) { _productRequest = table . CreateInstance < CreateProductRequest > (); } [Given(@\"the following products exist:\")] public async Task GivenTheFollowingProductsExist ( Table table ) { var products = table . CreateSet < CreateProductRequest > (); foreach ( var product in products ) { var response = await _client . PostAsJsonAsync ( \"/api/products\" , product ); Assert . True ( response . IsSuccessStatusCode ); } } [Given(@\"a product exists with:\")] public async Task GivenAProductExistsWith ( Table table ) { _productRequest = table . CreateInstance < CreateProductRequest > (); _response = await _client . PostAsJsonAsync ( \"/api/products\" , _productRequest ); _createdProduct = await _response . Content . ReadFromJsonAsync < Product > (); _scenarioContext [ \"ExistingProduct\" ] = _createdProduct ; } [When(@\"I create the product\")] public async Task WhenICreateTheProduct () { _response = await _client . PostAsJsonAsync ( \"/api/products\" , _productRequest ); if ( _response . IsSuccessStatusCode ) { _createdProduct = await _response . Content . ReadFromJsonAsync < Product > (); } } [When(@\"I attempt to create the product\")] public async Task WhenIAttemptToCreateTheProduct () { _response = await _client . PostAsJsonAsync ( \"/api/products\" , _productRequest ); } [When(@\"I request all products\")] public async Task WhenIRequestAllProducts () { _response = await _client . GetAsync ( \"/api/products\" ); if ( _response . IsSuccessStatusCode ) { _retrievedProducts = await _response . Content . ReadFromJsonAsync < List < Product >> (); } } [When(@\"I update the product with:\")] public async Task WhenIUpdateTheProductWith ( Table table ) { var existingProduct = _scenarioContext [ \"ExistingProduct\" ] as Product ; var updateRequest = table . CreateInstance < CreateProductRequest > (); _response = await _client . PutAsJsonAsync ( $\"/api/products/{existingProduct!.Id}\" , updateRequest ); if ( _response . IsSuccessStatusCode ) { _createdProduct = await _response . Content . ReadFromJsonAsync < Product > (); } } [Then(@\"the product should be created successfully\")] public void ThenTheProductShouldBeCreatedSuccessfully () { Assert . Equal ( HttpStatusCode . Created , _response ! . StatusCode ); Assert . NotNull ( _createdProduct ); } [Then(@\"the product should have an ID\")] public void ThenTheProductShouldHaveAnId () { Assert . True ( _createdProduct ! . Id > 0 ); } [Then(@\"the product should be retrievable by ID\")] public async Task ThenTheProductShouldBeRetrievableById () { var response = await _client . GetAsync ( $\"/api/products/{_createdProduct!.Id}\" ); Assert . True ( response . IsSuccessStatusCode ); var retrievedProduct = await response . Content . ReadFromJsonAsync < Product > (); Assert . Equal ( _createdProduct . Name , retrievedProduct ! . Name ); Assert . Equal ( _createdProduct . Price , retrievedProduct . Price ); } [Then(@\"I should receive (.*) products\")] public void ThenIShouldReceiveProducts ( int expectedCount ) { Assert . Equal ( HttpStatusCode . OK , _response ! . StatusCode ); Assert . NotNull ( _retrievedProducts ); Assert . Equal ( expectedCount , _retrievedProducts . Count ); } [Then(@\"the products should be ordered by creation date\")] public void ThenTheProductsShouldBeOrderedByCreationDate () { for ( int i = 1 ; i < _retrievedProducts ! . Count ; i ++ ) { Assert . True ( _retrievedProducts [ i - 1 ]. CreatedAt <= _retrievedProducts [ i ]. CreatedAt ); } } [Then(@\"the creation should fail with validation errors\")] public void ThenTheCreationShouldFailWithValidationErrors () { Assert . Equal ( HttpStatusCode . BadRequest , _response ! . StatusCode ); } [Then(@\"I should receive appropriate error messages\")] public async Task ThenIShouldReceiveAppropriateErrorMessages () { var errorContent = await _response ! . Content . ReadAsStringAsync (); Assert . Contains ( \"validation\" , errorContent . ToLower ()); } [Then(@\"the product should be updated successfully\")] public void ThenTheProductShouldBeUpdatedSuccessfully () { Assert . Equal ( HttpStatusCode . OK , _response ! . StatusCode ); Assert . NotNull ( _createdProduct ); } [Then(@\"the updated product should be retrievable\")] public async Task ThenTheUpdatedProductShouldBeRetrievable () { var response = await _client . GetAsync ( $\"/api/products/{_createdProduct!.Id}\" ); Assert . True ( response . IsSuccessStatusCode ); } } }","title":"Step 3: Implement Step Definitions"},{"location":"4_testing/bdd_tdd/#example-3-tdd-with-react-native","text":"Let's implement TDD for a React Native product list component.","title":"Example 3: TDD with React Native"},{"location":"4_testing/bdd_tdd/#step-1-set-up-testing-environment","text":"npx react-native init ProductCatalogApp --template react-native-template-typescript cd ProductCatalogApp npm install --save-dev @testing-library/react-native @testing-library/jest-native","title":"Step 1: Set Up Testing Environment"},{"location":"4_testing/bdd_tdd/#step-2-write-failing-test","text":"// __tests__/components/ProductList.test.tsx import React from 'react' ; import { render , screen , waitFor } from '@testing-library/react-native' ; import { ProductList } from '../../src/components/ProductList' ; import { Product } from '../../src/types/Product' ; // Mock the fetch function global . fetch = jest . fn (); describe ( 'ProductList' , () => { beforeEach (() => { jest . clearAllMocks (); }); it ( 'displays loading indicator while fetching products' , () => { // Arrange ( fetch as jest . Mock ). mockResolvedValueOnce ({ ok : true , json : () => Promise . resolve ([]), }); // Act render ( < ProductList /> ); // Assert expect ( screen . getByTestId ( 'loading-indicator' )). toBeTruthy (); }); it ( 'displays products when fetch is successful' , async () => { // Arrange const mockProducts : Product [] = [ { id : 1 , name : 'Laptop' , price : 999.99 , description : 'Gaming laptop' }, { id : 2 , name : 'Mouse' , price : 29.99 , description : 'Wireless mouse' }, ]; ( fetch as jest . Mock ). mockResolvedValueOnce ({ ok : true , json : () => Promise . resolve ( mockProducts ), }); // Act render ( < ProductList /> ); // Assert await waitFor (() => { expect ( screen . getByText ( 'Laptop' )). toBeTruthy (); expect ( screen . getByText ( '$999.99' )). toBeTruthy (); expect ( screen . getByText ( 'Mouse' )). toBeTruthy (); expect ( screen . getByText ( '$29.99' )). toBeTruthy (); }); }); it ( 'displays error message when fetch fails' , async () => { // Arrange ( fetch as jest . Mock ). mockRejectedValueOnce ( new Error ( 'Network error' )); // Act render ( < ProductList /> ); // Assert await waitFor (() => { expect ( screen . getByText ( 'Error loading products' )). toBeTruthy (); }); }); it ( 'calls fetch with correct URL' , () => { // Arrange & Act render ( < ProductList /> ); // Assert expect ( fetch ). toHaveBeenCalledWith ( 'https://api.example.com/products' ); }); });","title":"Step 2: Write Failing Test"},{"location":"4_testing/bdd_tdd/#step-3-implement-component-green-phase","text":"// src/types/Product.ts export interface Product { id : number ; name : string ; price : number ; description : string ; } // src/components/ProductList.tsx import React , { useEffect , useState } from 'react' ; import { View , Text , FlatList , ActivityIndicator , StyleSheet , Alert , } from 'react-native' ; import { Product } from '../types/Product' ; export const ProductList : React.FC = () => { const [ products , setProducts ] = useState < Product [] > ([]); const [ loading , setLoading ] = useState ( true ); const [ error , setError ] = useState < string | null > ( null ); useEffect (() => { fetchProducts (); }, []); const fetchProducts = async () => { try { setLoading ( true ); setError ( null ); const response = await fetch ( 'https://api.example.com/products' ); if ( ! response . ok ) { throw new Error ( `HTTP error! status: ${ response . status } ` ); } const data = await response . json (); setProducts ( data ); } catch ( err ) { const errorMessage = err instanceof Error ? err . message : 'Unknown error' ; setError ( 'Error loading products' ); console . error ( 'Error fetching products:' , errorMessage ); } finally { setLoading ( false ); } }; const renderProduct = ({ item } : { item : Product }) => ( < View style = { styles . productItem } > < Text style = { styles . productName } > { item . name } < /Text> < Text style = { styles . productPrice } > $ { item . price . toFixed ( 2 )} < /Text> < Text style = { styles . productDescription } > { item . description } < /Text> < /View> ); if ( loading ) { return ( < View style = { styles . centerContainer } > < ActivityIndicator testID = \"loading-indicator\" size = \"large\" color = \"#0000ff\" /> < Text > Loading products ... < /Text> < /View> ); } if ( error ) { return ( < View style = { styles . centerContainer } > < Text style = { styles . errorText } > { error } < /Text> < /View> ); } return ( < FlatList data = { products } renderItem = { renderProduct } keyExtractor = {( item ) => item . id . toString ()} style = { styles . container } testID = \"product-list\" /> ); }; const styles = StyleSheet . create ({ container : { flex : 1 , backgroundColor : '#f5f5f5' , }, centerContainer : { flex : 1 , justifyContent : 'center' , alignItems : 'center' , padding : 20 , }, productItem : { backgroundColor : 'white' , padding : 16 , marginHorizontal : 16 , marginVertical : 8 , borderRadius : 8 , shadowColor : '#000' , shadowOffset : { width : 0 , height : 2 }, shadowOpacity : 0.1 , shadowRadius : 4 , elevation : 3 , }, productName : { fontSize : 18 , fontWeight : 'bold' , marginBottom : 4 , }, productPrice : { fontSize : 16 , color : '#007AFF' , fontWeight : '600' , marginBottom : 4 , }, productDescription : { fontSize : 14 , color : '#666' , }, errorText : { color : 'red' , fontSize : 16 , textAlign : 'center' , }, });","title":"Step 3: Implement Component (Green Phase)"},{"location":"4_testing/bdd_tdd/#common-pitfalls","text":"","title":"Common Pitfalls"},{"location":"4_testing/bdd_tdd/#1-writing-tests-after-implementation","text":"Problem : Writing tests after code is implemented reduces their effectiveness and may lead to tests that confirm existing bugs. Solution : Always write tests first (Red phase) to ensure tests actually validate the intended behavior: // BAD: Testing existing implementation it ( 'should do what the current code does' , () => { const result = existingFunction (); expect ( result ). toBe ( whatever_it_currently_returns ); }); // GOOD: Testing intended behavior it ( 'should calculate total price including tax' , () => { const order = new Order ([ { price : 100 , quantity : 2 }, { price : 50 , quantity : 1 } ]); const total = order . calculateTotalWithTax ( 0.1 ); // 10% tax expect ( total ). toBe ( 275 ); // (200 + 50) * 1.1 });","title":"1. Writing Tests After Implementation"},{"location":"4_testing/bdd_tdd/#2-over-mocking-in-tests","text":"Problem : Excessive mocking can make tests brittle and reduce confidence in the system. Solution : Use mocks judiciously and prefer integration tests where appropriate: // BAD: Over-mocking [Fact] public void CalculateTotal_ShouldReturnCorrectValue () { var mockItem1 = new Mock < IOrderItem > (); mockItem1 . Setup ( x => x . GetPrice ()). Returns ( 10 ); var mockItem2 = new Mock < IOrderItem > (); mockItem2 . Setup ( x => x . GetPrice ()). Returns ( 20 ); var order = new Order (); order . AddItem ( mockItem1 . Object ); order . AddItem ( mockItem2 . Object ); Assert . Equal ( 30 , order . CalculateTotal ()); } // GOOD: Testing with real objects [Fact] public void CalculateTotal_WithRealItems_ReturnsCorrectValue () { var order = new Order (); order . AddItem ( new OrderItem ( \"Product1\" , 10 , 1 )); order . AddItem ( new OrderItem ( \"Product2\" , 20 , 1 )); Assert . Equal ( 30 , order . CalculateTotal ()); }","title":"2. Over-Mocking in Tests"},{"location":"4_testing/bdd_tdd/#3-poor-bdd-scenario-writing","text":"Problem : BDD scenarios that are too technical or don't reflect real user behavior. Solution : Write scenarios from the user's perspective using business language: # BAD: Too technical Scenario: POST request to /api/products returns 201 Given I send a POST request to /api/products When the request contains valid JSON Then the response should be 201 And the Location header should be set # GOOD: Business-focused Scenario: Store manager adds new product to catalog Given I am logged in as a store manager When I add a new product \" Gaming Laptop \" priced at $ 1299.99 Then the product should appear in the catalog And customers should be able to find it by searching","title":"3. Poor BDD Scenario Writing"},{"location":"4_testing/bdd_tdd/#4-ignoring-test-performance","text":"Problem : Slow tests discourage running them frequently, reducing their value. Solution : Use appropriate test isolation and consider test containers for integration tests: # docker-compose.test.yml for fast test database version : '3.8' services : test-db : image : registry.access.redhat.com/rhel8/postgresql-13 environment : POSTGRESQL_DATABASE : testdb POSTGRESQL_USER : testuser POSTGRESQL_PASSWORD : testpass ports : - \"5433:5432\" tmpfs : - /var/lib/postgresql/data # In-memory for speed","title":"4. Ignoring Test Performance"},{"location":"4_testing/bdd_tdd/#best-practices","text":"","title":"Best Practices"},{"location":"4_testing/bdd_tdd/#tdd-best-practices","text":"Start with the simplest test : Begin with basic scenarios before edge cases Write minimal code to pass : Don't over-engineer in the Green phase Refactor regularly : Improve code quality after tests pass Test behavior, not implementation : Focus on what the code should do, not how Use descriptive test names : Make test intent clear from the name // Good test naming conventions [Fact] public void CalculateDiscount_WithValidCustomerAndAmount_ReturnsCorrectDiscount () [Fact] public void CalculateDiscount_WithInvalidAmount_ThrowsArgumentException () [Fact] public void CalculateDiscount_WithNullCustomer_ThrowsArgumentNullException ()","title":"TDD Best Practices"},{"location":"4_testing/bdd_tdd/#bdd-best-practices","text":"Collaborate on scenarios : Include stakeholders in scenario writing Use ubiquitous language : Use domain terms consistently Keep scenarios focused : One behavior per scenario Use data tables effectively : For parameterized scenarios Maintain living documentation : Keep scenarios updated with code changes # Example of focused, business-oriented scenario Scenario: Customer receives loyalty discount Given I am a loyalty customer with \" Gold \" status And I have an order worth $ 200 When I apply my loyalty discount Then I should receive a 15 % discount And my final total should be $ 170","title":"BDD Best Practices"},{"location":"4_testing/bdd_tdd/#integration-with-containers","text":"Use Testcontainers : For realistic integration tests Isolate test databases : Each test run should use clean data Container health checks : Ensure services are ready before testing Resource cleanup : Properly dispose of containers after tests // Example using Testcontainers with PostgreSQL public class ProductServiceIntegrationTests : IAsyncLifetime { private readonly PostgreSqlContainer _postgres = new PostgreSqlBuilder () . WithImage ( \"registry.access.redhat.com/rhel8/postgresql-13\" ) . WithDatabase ( \"testdb\" ) . WithUsername ( \"testuser\" ) . WithPassword ( \"testpass\" ) . Build (); public async Task InitializeAsync () { await _postgres . StartAsync (); } public async Task DisposeAsync () { await _postgres . DisposeAsync (); } }","title":"Integration with Containers"},{"location":"4_testing/bdd_tdd/#tools-and-resources","text":"","title":"Tools and Resources"},{"location":"4_testing/bdd_tdd/#net-testing-tools","text":"xUnit : Modern testing framework for .NET SpecFlow : BDD framework for .NET Moq : Mocking framework Testcontainers : Integration testing with containers Coverlet : Code coverage analysis ReportGenerator : Coverage report generation","title":".NET Testing Tools"},{"location":"4_testing/bdd_tdd/#react-native-testing-tools","text":"Jest : JavaScript testing framework React Native Testing Library : Component testing utilities Cucumber.js : BDD framework for JavaScript MSW : API mocking for testing Detox : End-to-end testing for React Native","title":"React Native Testing Tools"},{"location":"4_testing/bdd_tdd/#container-testing-setup","text":"# Containerfile.test - Testing environment with UBI FROM registry.access.redhat.com/ubi8/dotnet-60 WORKDIR /app # Install development tools RUN dnf install -y git # Copy test projects COPY *.Tests/*.csproj ./Tests/ COPY *.Api/*.csproj ./Api/ # Restore dependencies RUN dotnet restore Tests/ && dotnet restore Api/ # Copy source code COPY . . # Run tests CMD [ \"dotnet\" , \"test\" , \"Tests/\" , \"--logger\" , \"trx\" , \"--results-directory\" , \"/app/TestResults\" ]","title":"Container Testing Setup"},{"location":"4_testing/bdd_tdd/#useful-resources","text":"xUnit Documentation SpecFlow Documentation React Native Testing Library Testcontainers Documentation BDD Best Practices","title":"Useful Resources"},{"location":"4_testing/bdd_tdd/#hands-on-exercise","text":"","title":"Hands-on Exercise"},{"location":"4_testing/bdd_tdd/#exercise-complete-e-commerce-testing-suite","text":"Implement a comprehensive testing suite for an e-commerce application using both TDD and BDD approaches. Requirements: Backend (.NET API): Product catalog management Shopping cart functionality Order processing User authentication Frontend (React Native): Product browsing Cart management Checkout process User profile Testing Requirements: Unit tests with 90%+ coverage BDD scenarios for key user journeys Integration tests using Testcontainers End-to-end tests for critical paths Performance tests for API endpoints Deliverables: Complete test suite with documentation BDD feature files with business scenarios Containerized testing environment CI/CD pipeline configuration for automated testing Test reporting and coverage analysis Evaluation Criteria: Test coverage and quality BDD scenario clarity and business alignment Integration test effectiveness Performance test results Documentation quality","title":"Exercise: Complete E-commerce Testing Suite"},{"location":"4_testing/bdd_tdd/#summary","text":"BDD and TDD practices form the foundation of quality software development by ensuring code correctness, maintainability, and business alignment. Key takeaways include: TDD improves design through the Red-Green-Refactor cycle BDD ensures business alignment through collaborative scenario development Test-first development catches bugs early and reduces costs Comprehensive testing includes unit, integration, and end-to-end tests Container-based testing provides realistic and isolated test environments Living documentation through tests maintains system knowledge Continuous testing in CI/CD pipelines ensures ongoing quality By implementing these practices with .NET and React Native applications using Podman and Red Hat UBI images, development teams can deliver reliable, well-tested software that meets both technical and business requirements. The combination of TDD and BDD creates a robust development workflow that scales from individual developers to large enterprise teams.","title":"Summary"},{"location":"4_testing/clean_architecture/","text":"","title":"Clean Architecture"},{"location":"4_testing/mocking_dependent_systems_apis/","text":"","title":"API Mocking Strategies"},{"location":"4_testing/performance_testing_containers/","text":"","title":"Performance Testing in Containers"},{"location":"4_testing/secure_coding/","text":"","title":"Secure Coding Practices"},{"location":"4_testing/using_composefilesforlocaldev/","text":"Local Development with podman compose  \u00b6 Overview \u00b6 Local development environments are crucial for developer productivity and application quality. Using podman compose , developers can create consistent, reproducible development environments that closely mirror production while remaining lightweight and fast to start. This guide demonstrates how to set up and manage local development environments for .NET and React Native applications using podman compose  with Red Hat UBI images. podman compose  provides the same functionality as Docker Compose but with enhanced security through rootless containers, making it ideal for enterprise development environments where security is paramount. Key Concepts \u00b6 podman compose  Benefits \u00b6 Rootless Containers : Enhanced security without requiring root privileges Development Consistency : Same environment across all developer machines Production Parity : Mirror production architecture locally Resource Efficiency : Lightweight containers start quickly Service Isolation : Each service runs independently Easy Debugging : Individual service access and log monitoring Development vs Production \u00b6 Aspect Development Production Volume Mounts Source code hot reload Built application artifacts Environment Variables Development settings Production configuration Networking Direct port access Load balancer/ingress Persistence Temporary volumes Persistent storage Monitoring Basic logging Full observability stack Security Simplified for debugging Hardened security policies Container Orchestration Patterns \u00b6 Multi-service Applications : Frontend, backend, and database coordination Service Dependencies : Proper startup ordering and health checks Development Overrides : Different configurations for local development Hot Reloading : Live code updates without container rebuilds Database Management : Consistent data seeding and migrations Prerequisites \u00b6 Podman and podman compose  installed and configured Understanding of containerization concepts Basic knowledge of YAML configuration Familiarity with .NET and React Native development Understanding of networking and service communication Installation Requirements \u00b6 # Install Podman and podman compose  # On RHEL/CentOS/Fedora sudo dnf install podman podman compose # On macOS brew install podman pip3 install podman compose # Verify installation podman --version podman compose --version Practical Examples \u00b6 Example 1: Full-Stack E-commerce Development Environment \u00b6 Let's create a comprehensive development environment for an e-commerce application with multiple services. Step 1: Project Structure \u00b6 ecommerce-dev/ \u251c\u2500\u2500 compose.yml \u251c\u2500\u2500 podman-compose.override.yml \u251c\u2500\u2500 .env \u251c\u2500\u2500 api/ \u2502 \u251c\u2500\u2500 Containerfile.dev \u2502 \u251c\u2500\u2500 UserService/ \u2502 \u251c\u2500\u2500 ProductService/ \u2502 \u251c\u2500\u2500 OrderService/ \u2502 \u2514\u2500\u2500 PaymentService/ \u251c\u2500\u2500 web/ \u2502 \u251c\u2500\u2500 Containerfile.dev \u2502 \u2514\u2500\u2500 src/ \u251c\u2500\u2500 mobile/ \u2502 \u251c\u2500\u2500 Containerfile.dev \u2502 \u2514\u2500\u2500 src/ \u251c\u2500\u2500 database/ \u2502 \u251c\u2500\u2500 init-scripts/ \u2502 \u2514\u2500\u2500 seed-data/ \u2514\u2500\u2500 infrastructure/ \u251c\u2500\u2500 nginx/ \u251c\u2500\u2500 monitoring/ \u2514\u2500\u2500 scripts/ Step 2: Main Compose Configuration \u00b6 # compose.yml version : '3.8' services : # Reverse Proxy and Load Balancer nginx : image : registry.access.redhat.com/ubi8/nginx-120 container_name : ecommerce-nginx ports : - \"80:8080\" - \"443:8443\" volumes : - ./infrastructure/nginx/nginx.conf:/etc/nginx/nginx.conf:Z - ./infrastructure/nginx/ssl:/etc/nginx/ssl:Z depends_on : - user-service - product-service - order-service - web-app networks : - app-network restart : unless-stopped # User Management Service user-service : build : context : ./api/UserService Containerfile : Containerfile.dev container_name : ecommerce-user-service environment : - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=http://+:8080 - ConnectionStrings__DefaultConnection=Host=postgres;Database=userdb;Username=userservice;Password=${DB_PASSWORD} - JWT__SecretKey=${JWT_SECRET} - JWT__Issuer=ecommerce-dev - JWT__Audience=ecommerce-users - Redis__ConnectionString=redis:6379 - Logging__LogLevel__Default=Information - Logging__LogLevel__Microsoft=Warning ports : - \"5001:8080\" depends_on : postgres : condition : service_healthy redis : condition : service_healthy volumes : - ./api/UserService:/app:Z - user-service-nuget:/root/.nuget/packages networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s # Product Catalog Service product-service : build : context : ./api/ProductService Containerfile : Containerfile.dev container_name : ecommerce-product-service environment : - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=http://+:8080 - ConnectionStrings__DefaultConnection=Host=postgres;Database=productdb;Username=productservice;Password=${DB_PASSWORD} - Redis__ConnectionString=redis:6379 - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 - Storage__ConnectionString=minio:9000 - Storage__AccessKey=${MINIO_ACCESS_KEY} - Storage__SecretKey=${MINIO_SECRET_KEY} ports : - \"5002:8080\" depends_on : postgres : condition : service_healthy redis : condition : service_healthy rabbitmq : condition : service_healthy volumes : - ./api/ProductService:/app:Z - product-service-nuget:/root/.nuget/packages networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s # Order Processing Service order-service : build : context : ./api/OrderService Containerfile : Containerfile.dev container_name : ecommerce-order-service environment : - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=http://+:8080 - ConnectionStrings__DefaultConnection=Host=postgres;Database=orderdb;Username=orderservice;Password=${DB_PASSWORD} - Services__UserService__BaseUrl=http://user-service:8080 - Services__ProductService__BaseUrl=http://product-service:8080 - Services__PaymentService__BaseUrl=http://payment-service:8080 - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 - Redis__ConnectionString=redis:6379 ports : - \"5003:8080\" depends_on : postgres : condition : service_healthy redis : condition : service_healthy rabbitmq : condition : service_healthy user-service : condition : service_healthy product-service : condition : service_healthy volumes : - ./api/OrderService:/app:Z - order-service-nuget:/root/.nuget/packages networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s # Payment Processing Service payment-service : build : context : ./api/PaymentService Containerfile : Containerfile.dev container_name : ecommerce-payment-service environment : - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=http://+:8080 - ConnectionStrings__DefaultConnection=Host=postgres;Database=paymentdb;Username=paymentservice;Password=${DB_PASSWORD} - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 - PaymentGateway__ApiKey=${PAYMENT_GATEWAY_API_KEY} - PaymentGateway__SecretKey=${PAYMENT_GATEWAY_SECRET_KEY} - PaymentGateway__Environment=sandbox ports : - \"5004:8080\" depends_on : postgres : condition : service_healthy rabbitmq : condition : service_healthy volumes : - ./api/PaymentService:/app:Z - payment-service-nuget:/root/.nuget/packages networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s # Web Application (React) web-app : build : context : ./web Containerfile : Containerfile.dev container_name : ecommerce-web-app environment : - NODE_ENV=development - REACT_APP_API_BASE_URL=http://localhost/api - REACT_APP_WEBSOCKET_URL=ws://localhost/ws - CHOKIDAR_USEPOLLING=true ports : - \"3000:3000\" volumes : - ./web:/app:Z - web-app-node-modules:/app/node_modules networks : - app-network restart : unless-stopped stdin_open : true tty : true # PostgreSQL Database postgres : image : registry.access.redhat.com/rhel8/postgresql-13 container_name : ecommerce-postgres environment : - POSTGRESQL_USER=postgres - POSTGRESQL_PASSWORD=${DB_PASSWORD} - POSTGRESQL_DATABASE=postgres ports : - \"5432:5432\" volumes : - postgres_data:/var/lib/pgsql/data - ./database/init-scripts:/docker-entrypoint-initdb.d:Z networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD-SHELL\" , \"pg_isready -U postgres\" ] interval : 10s timeout : 5s retries : 5 # Redis Cache redis : image : registry.access.redhat.com/rhel8/redis-6 container_name : ecommerce-redis command : redis-server --appendonly yes --requirepass ${REDIS_PASSWORD} ports : - \"6379:6379\" volumes : - redis_data:/var/lib/redis/data networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"redis-cli\" , \"--raw\" , \"incr\" , \"ping\" ] interval : 10s timeout : 3s retries : 5 # RabbitMQ Message Broker rabbitmq : image : registry.access.redhat.com/ubi8/ubi:latest container_name : ecommerce-rabbitmq environment : - RABBITMQ_DEFAULT_USER=guest - RABBITMQ_DEFAULT_PASS=guest - RABBITMQ_DEFAULT_VHOST=/ ports : - \"5672:5672\" - \"15672:15672\" volumes : - rabbitmq_data:/var/lib/rabbitmq - ./infrastructure/rabbitmq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:Z networks : - app-network restart : unless-stopped healthcheck : test : rabbitmq-diagnostics -q ping interval : 30s timeout : 10s retries : 5 # MinIO Object Storage minio : image : quay.io/minio/minio:latest container_name : ecommerce-minio command : server /data --console-address \":9001\" environment : - MINIO_ROOT_USER=${MINIO_ACCESS_KEY} - MINIO_ROOT_PASSWORD=${MINIO_SECRET_KEY} ports : - \"9000:9000\" - \"9001:9001\" volumes : - minio_data:/data networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:9000/minio/health/live\" ] interval : 30s timeout : 20s retries : 3 volumes : postgres_data : redis_data : rabbitmq_data : minio_data : user-service-nuget : product-service-nuget : order-service-nuget : payment-service-nuget : web-app-node-modules : networks : app-network : driver : bridge ipam : config : - subnet : 172.20.0.0/16 Step 3: Development Override Configuration \u00b6 # podman-compose.override.yml version : '3.8' services : user-service : environment : - ASPNETCORE_ENVIRONMENT=Development - Logging__LogLevel__Default=Debug - Logging__LogLevel__Microsoft=Information - Development__EnableSensitiveDataLogging=true volumes : - ./api/UserService:/app:Z - user-service-nuget:/root/.nuget/packages command : > bash -c \" dotnet restore && dotnet watch run --urls http://+:8080 \" product-service : environment : - ASPNETCORE_ENVIRONMENT=Development - Logging__LogLevel__Default=Debug - Development__EnableSensitiveDataLogging=true volumes : - ./api/ProductService:/app:Z - product-service-nuget:/root/.nuget/packages command : > bash -c \" dotnet restore && dotnet watch run --urls http://+:8080 \" order-service : environment : - ASPNETCORE_ENVIRONMENT=Development - Logging__LogLevel__Default=Debug - Development__EnableSensitiveDataLogging=true volumes : - ./api/OrderService:/app:Z - order-service-nuget:/root/.nuget/packages command : > bash -c \" dotnet restore && dotnet watch run --urls http://+:8080 \" payment-service : environment : - ASPNETCORE_ENVIRONMENT=Development - Logging__LogLevel__Default=Debug - Development__EnableSensitiveDataLogging=true volumes : - ./api/PaymentService:/app:Z - payment-service-nuget:/root/.nuget/packages command : > bash -c \" dotnet restore && dotnet watch run --urls http://+:8080 \" web-app : environment : - NODE_ENV=development - FAST_REFRESH=true - CHOKIDAR_USEPOLLING=true - WATCHPACK_POLLING=true command : npm start stdin_open : true tty : true # Development tools pgadmin : image : dpage/pgadmin4:latest container_name : ecommerce-pgadmin environment : - PGADMIN_DEFAULT_EMAIL=admin@example.com - PGADMIN_DEFAULT_PASSWORD=admin ports : - \"5050:80\" volumes : - pgadmin_data:/var/lib/pgadmin networks : - app-network restart : unless-stopped redis-commander : image : rediscommander/redis-commander:latest container_name : ecommerce-redis-commander environment : - REDIS_HOSTS=local:redis:6379 - REDIS_PASSWORD=${REDIS_PASSWORD} ports : - \"8081:8081\" networks : - app-network restart : unless-stopped volumes : pgadmin_data : Step 4: Environment Configuration \u00b6 # .env # Database Configuration DB_PASSWORD = dev_password_123 POSTGRES_DB = ecommerce_dev # Redis Configuration REDIS_PASSWORD = redis_dev_password # JWT Configuration JWT_SECRET = your_super_secret_jwt_key_for_development_only # MinIO Configuration MINIO_ACCESS_KEY = minioadmin MINIO_SECRET_KEY = minioadmin123 # Payment Gateway (Sandbox) PAYMENT_GATEWAY_API_KEY = sandbox_api_key PAYMENT_GATEWAY_SECRET_KEY = sandbox_secret_key # Development Settings ASPNETCORE_ENVIRONMENT = Development NODE_ENV = development Step 5: Development Containerfiles \u00b6 .NET Service Development Containerfile: # api/UserService/Containerfile.dev FROM registry.access.redhat.com/ubi8/dotnet-60 # Install development tools USER root RUN dnf update -y && \\ dnf install -y curl procps-ng && \\ dnf clean all # Create app user RUN groupadd -r appuser && useradd -r -g appuser appuser # Set working directory WORKDIR /app # Copy project files COPY --chown = appuser:appuser *.csproj ./ RUN dotnet restore # Copy source code COPY --chown = appuser:appuser . ./ # Switch to app user USER appuser # Expose port EXPOSE 8080 # Install dotnet tools for hot reload RUN dotnet tool install --global dotnet-ef RUN dotnet tool install --global dotnet-watch ENV PATH = \" $PATH :/home/appuser/.dotnet/tools\" # Default command for development (can be overridden) CMD [ \"dotnet\" , \"watch\" , \"run\" , \"--urls\" , \"http://+:8080\" ] React Development Containerfile: # web/Containerfile.dev FROM registry.access.redhat.com/ubi8/nodejs-16 # Install development tools USER root RUN dnf update -y && \\ dnf install -y git curl && \\ dnf clean all # Create app user RUN groupadd -r appuser && useradd -r -g appuser appuser # Set working directory WORKDIR /app # Copy package files COPY --chown = appuser:appuser package*.json ./ # Switch to app user USER appuser # Install dependencies RUN npm ci # Copy source code COPY --chown = appuser:appuser . ./ # Expose port EXPOSE 3000 # Set environment for development ENV NODE_ENV = development ENV CHOKIDAR_USEPOLLING = true ENV FAST_REFRESH = true # Start development server CMD [ \"npm\" , \"start\" ] Example 2: React Native Development Environment \u00b6 For React Native development, we need a specialized setup: # mobile-dev/compose.yml version : '3.8' services : # React Native Metro Bundler metro-bundler : build : context : . Containerfile : Containerfile.metro container_name : rn-metro-bundler environment : - NODE_ENV=development - REACT_NATIVE_PACKAGER_HOSTNAME=0.0.0.0 ports : - \"8081:8081\" # Metro bundler - \"9090:9090\" # Flipper volumes : - ./src:/app/src:Z - ./assets:/app/assets:Z - rn-node-modules:/app/node_modules networks : - mobile-network restart : unless-stopped # Android Development Environment android-dev : build : context : . Containerfile : Containerfile.android container_name : rn-android-dev environment : - DISPLAY=${DISPLAY} volumes : - /tmp/.X11-unix:/tmp/.X11-unix:Z - ./:/app:Z - android-sdk:/opt/android-sdk - gradle-cache:/root/.gradle networks : - mobile-network privileged : true restart : unless-stopped # API Mock Server for Development mock-api : image : registry.access.redhat.com/ubi8/nodejs-16 container_name : rn-mock-api working_dir : /app command : > bash -c \" npm install -g json-server && json-server --watch db.json --host 0.0.0.0 --port 3001 \" ports : - \"3001:3001\" volumes : - ./mock-data:/app:Z networks : - mobile-network restart : unless-stopped volumes : rn-node-modules : android-sdk : gradle-cache : networks : mobile-network : driver : bridge Example 3: Database Management and Seeding \u00b6 -- database/init-scripts/01-create-databases.sql -- Create separate databases for each service CREATE DATABASE userdb ; CREATE DATABASE productdb ; CREATE DATABASE orderdb ; CREATE DATABASE paymentdb ; -- Create service users CREATE USER userservice WITH ENCRYPTED PASSWORD 'dev_password_123' ; CREATE USER productservice WITH ENCRYPTED PASSWORD 'dev_password_123' ; CREATE USER orderservice WITH ENCRYPTED PASSWORD 'dev_password_123' ; CREATE USER paymentservice WITH ENCRYPTED PASSWORD 'dev_password_123' ; -- Grant permissions GRANT ALL PRIVILEGES ON DATABASE userdb TO userservice ; GRANT ALL PRIVILEGES ON DATABASE productdb TO productservice ; GRANT ALL PRIVILEGES ON DATABASE orderdb TO orderservice ; GRANT ALL PRIVILEGES ON DATABASE paymentdb TO paymentservice ; -- database/init-scripts/02-seed-data.sql \\ c productdb ; -- Sample product data for development INSERT INTO products ( id , name , description , price , stock_quantity , category_id , created_at ) VALUES ( '11111111-1111-1111-1111-111111111111' , 'Gaming Laptop' , 'High-performance gaming laptop' , 1299 . 99 , 10 , '22222222-2222-2222-2222-222222222222' , NOW ()), ( '33333333-3333-3333-3333-333333333333' , 'Wireless Mouse' , 'Ergonomic wireless mouse' , 29 . 99 , 50 , '44444444-4444-4444-4444-444444444444' , NOW ()), ( '55555555-5555-5555-5555-555555555555' , 'Mechanical Keyboard' , 'RGB mechanical keyboard' , 129 . 99 , 25 , '44444444-4444-4444-4444-444444444444' , NOW ()); \\ c userdb ; -- Sample user data for development INSERT INTO users ( id , email , first_name , last_name , password_hash , created_at ) VALUES ( 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa' , 'john.doe@example.com' , 'John' , 'Doe' , '$2a$11$example_hash' , NOW ()), ( 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb' , 'jane.smith@example.com' , 'Jane' , 'Smith' , '$2a$11$example_hash' , NOW ()); Common Pitfalls \u00b6 1. Volume Mount Issues \u00b6 Problem : File permission errors or changes not reflecting in containers. Solution : Use proper SELinux contexts and understand rootless mapping: services : api : volumes : # Correct: Use :Z for SELinux relabeling - ./src:/app/src:Z # Incorrect: Missing SELinux context - ./src:/app/src 2. Service Startup Dependencies \u00b6 Problem : Services starting before dependencies are ready. Solution : Use proper health checks and depends_on conditions: services : api : depends_on : database : condition : service_healthy redis : condition : service_healthy healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s 3. Network Connectivity Issues \u00b6 Problem : Services can't communicate or resolve each other's names. Solution : Use explicit networks and proper service naming: networks : app-network : driver : bridge ipam : config : - subnet : 172.20.0.0/16 services : api : networks : - app-network environment : - DATABASE_HOST=postgres # Use service name for internal communication 4. Resource Consumption \u00b6 Problem : Development environment consuming too many system resources. Solution : Set resource limits and use efficient base images: services : api : deploy : resources : limits : memory : 512M cpus : '0.5' reservations : memory : 256M cpus : '0.25' Best Practices \u00b6 1. Environment Configuration \u00b6 # Use environment-specific overrides # compose.yml - Base configuration # podman-compose.override.yml - Development overrides # podman-compose.prod.yml - Production configuration services : api : environment : - ASPNETCORE_ENVIRONMENT=${ENVIRONMENT:-Development} - DATABASE_URL=${DATABASE_URL} - REDIS_URL=${REDIS_URL} 2. Development Scripts \u00b6 Create helper scripts for common development tasks: #!/bin/bash # scripts/dev-start.sh set -e echo \"\ud83d\ude80 Starting development environment...\" # Load environment variables if [ -f .env ] ; then export $( grep -v '^#' .env | xargs ) fi # Start services podman compose up -d postgres redis rabbitmq # Wait for databases to be ready echo \"\u23f3 Waiting for databases...\" sleep 10 # Run database migrations echo \"\ud83d\udd04 Running database migrations...\" podman compose exec user-service dotnet ef database update podman compose exec product-service dotnet ef database update podman compose exec order-service dotnet ef database update # Start application services echo \"\ud83d\udd27 Starting application services...\" podman compose up -d echo \"\u2705 Development environment is ready!\" echo \"\ud83c\udf10 Web app: http://localhost:3000\" echo \"\ud83d\udcca API docs: http://localhost/swagger\" echo \"\ud83d\uddc4\ufe0f Database admin: http://localhost:5050\" echo \"\ud83d\udce6 Redis admin: http://localhost:8081\" #!/bin/bash # scripts/dev-stop.sh echo \"\ud83d\uded1 Stopping development environment...\" podman compose down echo \"\ud83e\uddf9 Cleaning up...\" podman system prune -f --volumes echo \"\u2705 Development environment stopped!\" 3. Hot Reloading Configuration \u00b6 // Program.cs for .NET services if ( app . Environment . IsDevelopment ()) { app . UseDeveloperExceptionPage (); app . UseSwagger (); app . UseSwaggerUI (); // Enable detailed errors for development app . UseDeveloperExceptionPage (); // Enable CORS for local development app . UseCors ( builder => builder . AllowAnyOrigin () . AllowAnyMethod () . AllowAnyHeader ()); } 4. Logging and Debugging \u00b6 services : api : environment : - Logging__LogLevel__Default=Debug - Logging__LogLevel__Microsoft=Information - Logging__Console__IncludeScopes=true volumes : - ./logs:/app/logs:Z 5. Security in Development \u00b6 # Use secrets for sensitive data even in development secrets : db_password : file : ./secrets/db_password.txt jwt_secret : file : ./secrets/jwt_secret.txt services : api : secrets : - db_password - jwt_secret environment : - ConnectionStrings__DefaultConnection=Host=postgres;Database=mydb;Username=user;Password_File=/run/secrets/db_password Tools and Resources \u00b6 Development Tools \u00b6 Podman Desktop : GUI for container management Visual Studio Code : With Podman and development container extensions Postman : API testing and documentation pgAdmin : PostgreSQL administration Redis Commander : Redis data browser Monitoring and Debugging \u00b6 # Add to podman-compose.override.yml for development monitoring services : prometheus : image : prom/prometheus:latest ports : - \"9090:9090\" volumes : - ./monitoring/prometheus-dev.yml:/etc/prometheus/prometheus.yml:Z grafana : image : grafana/grafana:latest ports : - \"3001:3000\" environment : - GF_SECURITY_ADMIN_PASSWORD=admin volumes : - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards:Z Useful Commands \u00b6 # Start all services podman compose up -d # View logs for specific service podman compose logs -f user-service # Execute commands in running container podman compose exec user-service bash # Scale a service podman compose up -d --scale product-service = 2 # Rebuild and restart a service podman compose up -d --build user-service # Stop and remove all containers podman compose down # Remove volumes (careful with data loss) podman compose down -v # View resource usage podman stats # Clean up unused resources podman system prune -f Hands-on Exercise \u00b6 Exercise: Complete Microservices Development Environment \u00b6 Create a comprehensive development environment for a microservices-based application. Requirements: Application Services: Authentication service (.NET) Product catalog service (.NET) Order management service (.NET) Notification service (.NET) Web frontend (React) Mobile app development (React Native) Infrastructure Services: PostgreSQL database with multiple schemas Redis for caching and sessions RabbitMQ for event-driven communication MinIO for file storage Nginx as reverse proxy Development Features: Hot reloading for all services Database seeding with test data Automated database migrations Health checks for all services Centralized logging Development monitoring dashboard Developer Experience: One-command startup and shutdown Consistent environment across team Easy debugging and testing Documentation and helper scripts Deliverables: Complete podman compose  configuration Development Containerfiles for each service Database initialization and seeding scripts Development helper scripts Environment configuration management Documentation for onboarding new developers Performance optimization guide Evaluation Criteria: Environment startup time (< 2 minutes) Resource efficiency (< 4GB RAM usage) Hot reload functionality Service communication reliability Documentation quality Developer onboarding experience Summary \u00b6 Local development with podman compose  provides a powerful foundation for modern application development. Key takeaways include: Consistent Environments : podman compose  ensures all developers work with identical setups Production Parity : Local environments mirror production architecture and configuration Enhanced Security : Rootless containers provide better security isolation Developer Productivity : Hot reloading and automated setup reduce development friction Service Orchestration : Multi-service applications can be managed as cohesive units Resource Efficiency : Lightweight containers minimize system resource usage Debugging Capabilities : Individual service access and comprehensive logging aid troubleshooting By implementing these practices with .NET and React Native applications using podman compose  and Red Hat UBI images, development teams can achieve faster development cycles, improved code quality, and seamless collaboration. The investment in setting up comprehensive development environments pays dividends in reduced debugging time, consistent behavior across environments, and faster onboarding of new team members.","title":"Local Development with podman compose "},{"location":"4_testing/using_composefilesforlocaldev/#local-development-with-podman-compose","text":"","title":"Local Development with podman compose "},{"location":"4_testing/using_composefilesforlocaldev/#overview","text":"Local development environments are crucial for developer productivity and application quality. Using podman compose , developers can create consistent, reproducible development environments that closely mirror production while remaining lightweight and fast to start. This guide demonstrates how to set up and manage local development environments for .NET and React Native applications using podman compose  with Red Hat UBI images. podman compose  provides the same functionality as Docker Compose but with enhanced security through rootless containers, making it ideal for enterprise development environments where security is paramount.","title":"Overview"},{"location":"4_testing/using_composefilesforlocaldev/#key-concepts","text":"","title":"Key Concepts"},{"location":"4_testing/using_composefilesforlocaldev/#podman-compose-benefits","text":"Rootless Containers : Enhanced security without requiring root privileges Development Consistency : Same environment across all developer machines Production Parity : Mirror production architecture locally Resource Efficiency : Lightweight containers start quickly Service Isolation : Each service runs independently Easy Debugging : Individual service access and log monitoring","title":"podman compose  Benefits"},{"location":"4_testing/using_composefilesforlocaldev/#development-vs-production","text":"Aspect Development Production Volume Mounts Source code hot reload Built application artifacts Environment Variables Development settings Production configuration Networking Direct port access Load balancer/ingress Persistence Temporary volumes Persistent storage Monitoring Basic logging Full observability stack Security Simplified for debugging Hardened security policies","title":"Development vs Production"},{"location":"4_testing/using_composefilesforlocaldev/#container-orchestration-patterns","text":"Multi-service Applications : Frontend, backend, and database coordination Service Dependencies : Proper startup ordering and health checks Development Overrides : Different configurations for local development Hot Reloading : Live code updates without container rebuilds Database Management : Consistent data seeding and migrations","title":"Container Orchestration Patterns"},{"location":"4_testing/using_composefilesforlocaldev/#prerequisites","text":"Podman and podman compose  installed and configured Understanding of containerization concepts Basic knowledge of YAML configuration Familiarity with .NET and React Native development Understanding of networking and service communication","title":"Prerequisites"},{"location":"4_testing/using_composefilesforlocaldev/#installation-requirements","text":"# Install Podman and podman compose  # On RHEL/CentOS/Fedora sudo dnf install podman podman compose # On macOS brew install podman pip3 install podman compose # Verify installation podman --version podman compose --version","title":"Installation Requirements"},{"location":"4_testing/using_composefilesforlocaldev/#practical-examples","text":"","title":"Practical Examples"},{"location":"4_testing/using_composefilesforlocaldev/#example-1-full-stack-e-commerce-development-environment","text":"Let's create a comprehensive development environment for an e-commerce application with multiple services.","title":"Example 1: Full-Stack E-commerce Development Environment"},{"location":"4_testing/using_composefilesforlocaldev/#step-1-project-structure","text":"ecommerce-dev/ \u251c\u2500\u2500 compose.yml \u251c\u2500\u2500 podman-compose.override.yml \u251c\u2500\u2500 .env \u251c\u2500\u2500 api/ \u2502 \u251c\u2500\u2500 Containerfile.dev \u2502 \u251c\u2500\u2500 UserService/ \u2502 \u251c\u2500\u2500 ProductService/ \u2502 \u251c\u2500\u2500 OrderService/ \u2502 \u2514\u2500\u2500 PaymentService/ \u251c\u2500\u2500 web/ \u2502 \u251c\u2500\u2500 Containerfile.dev \u2502 \u2514\u2500\u2500 src/ \u251c\u2500\u2500 mobile/ \u2502 \u251c\u2500\u2500 Containerfile.dev \u2502 \u2514\u2500\u2500 src/ \u251c\u2500\u2500 database/ \u2502 \u251c\u2500\u2500 init-scripts/ \u2502 \u2514\u2500\u2500 seed-data/ \u2514\u2500\u2500 infrastructure/ \u251c\u2500\u2500 nginx/ \u251c\u2500\u2500 monitoring/ \u2514\u2500\u2500 scripts/","title":"Step 1: Project Structure"},{"location":"4_testing/using_composefilesforlocaldev/#step-2-main-compose-configuration","text":"# compose.yml version : '3.8' services : # Reverse Proxy and Load Balancer nginx : image : registry.access.redhat.com/ubi8/nginx-120 container_name : ecommerce-nginx ports : - \"80:8080\" - \"443:8443\" volumes : - ./infrastructure/nginx/nginx.conf:/etc/nginx/nginx.conf:Z - ./infrastructure/nginx/ssl:/etc/nginx/ssl:Z depends_on : - user-service - product-service - order-service - web-app networks : - app-network restart : unless-stopped # User Management Service user-service : build : context : ./api/UserService Containerfile : Containerfile.dev container_name : ecommerce-user-service environment : - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=http://+:8080 - ConnectionStrings__DefaultConnection=Host=postgres;Database=userdb;Username=userservice;Password=${DB_PASSWORD} - JWT__SecretKey=${JWT_SECRET} - JWT__Issuer=ecommerce-dev - JWT__Audience=ecommerce-users - Redis__ConnectionString=redis:6379 - Logging__LogLevel__Default=Information - Logging__LogLevel__Microsoft=Warning ports : - \"5001:8080\" depends_on : postgres : condition : service_healthy redis : condition : service_healthy volumes : - ./api/UserService:/app:Z - user-service-nuget:/root/.nuget/packages networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s # Product Catalog Service product-service : build : context : ./api/ProductService Containerfile : Containerfile.dev container_name : ecommerce-product-service environment : - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=http://+:8080 - ConnectionStrings__DefaultConnection=Host=postgres;Database=productdb;Username=productservice;Password=${DB_PASSWORD} - Redis__ConnectionString=redis:6379 - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 - Storage__ConnectionString=minio:9000 - Storage__AccessKey=${MINIO_ACCESS_KEY} - Storage__SecretKey=${MINIO_SECRET_KEY} ports : - \"5002:8080\" depends_on : postgres : condition : service_healthy redis : condition : service_healthy rabbitmq : condition : service_healthy volumes : - ./api/ProductService:/app:Z - product-service-nuget:/root/.nuget/packages networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s # Order Processing Service order-service : build : context : ./api/OrderService Containerfile : Containerfile.dev container_name : ecommerce-order-service environment : - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=http://+:8080 - ConnectionStrings__DefaultConnection=Host=postgres;Database=orderdb;Username=orderservice;Password=${DB_PASSWORD} - Services__UserService__BaseUrl=http://user-service:8080 - Services__ProductService__BaseUrl=http://product-service:8080 - Services__PaymentService__BaseUrl=http://payment-service:8080 - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 - Redis__ConnectionString=redis:6379 ports : - \"5003:8080\" depends_on : postgres : condition : service_healthy redis : condition : service_healthy rabbitmq : condition : service_healthy user-service : condition : service_healthy product-service : condition : service_healthy volumes : - ./api/OrderService:/app:Z - order-service-nuget:/root/.nuget/packages networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s # Payment Processing Service payment-service : build : context : ./api/PaymentService Containerfile : Containerfile.dev container_name : ecommerce-payment-service environment : - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=http://+:8080 - ConnectionStrings__DefaultConnection=Host=postgres;Database=paymentdb;Username=paymentservice;Password=${DB_PASSWORD} - EventBus__ConnectionString=amqp://guest:guest@rabbitmq:5672 - PaymentGateway__ApiKey=${PAYMENT_GATEWAY_API_KEY} - PaymentGateway__SecretKey=${PAYMENT_GATEWAY_SECRET_KEY} - PaymentGateway__Environment=sandbox ports : - \"5004:8080\" depends_on : postgres : condition : service_healthy rabbitmq : condition : service_healthy volumes : - ./api/PaymentService:/app:Z - payment-service-nuget:/root/.nuget/packages networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s # Web Application (React) web-app : build : context : ./web Containerfile : Containerfile.dev container_name : ecommerce-web-app environment : - NODE_ENV=development - REACT_APP_API_BASE_URL=http://localhost/api - REACT_APP_WEBSOCKET_URL=ws://localhost/ws - CHOKIDAR_USEPOLLING=true ports : - \"3000:3000\" volumes : - ./web:/app:Z - web-app-node-modules:/app/node_modules networks : - app-network restart : unless-stopped stdin_open : true tty : true # PostgreSQL Database postgres : image : registry.access.redhat.com/rhel8/postgresql-13 container_name : ecommerce-postgres environment : - POSTGRESQL_USER=postgres - POSTGRESQL_PASSWORD=${DB_PASSWORD} - POSTGRESQL_DATABASE=postgres ports : - \"5432:5432\" volumes : - postgres_data:/var/lib/pgsql/data - ./database/init-scripts:/docker-entrypoint-initdb.d:Z networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD-SHELL\" , \"pg_isready -U postgres\" ] interval : 10s timeout : 5s retries : 5 # Redis Cache redis : image : registry.access.redhat.com/rhel8/redis-6 container_name : ecommerce-redis command : redis-server --appendonly yes --requirepass ${REDIS_PASSWORD} ports : - \"6379:6379\" volumes : - redis_data:/var/lib/redis/data networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"redis-cli\" , \"--raw\" , \"incr\" , \"ping\" ] interval : 10s timeout : 3s retries : 5 # RabbitMQ Message Broker rabbitmq : image : registry.access.redhat.com/ubi8/ubi:latest container_name : ecommerce-rabbitmq environment : - RABBITMQ_DEFAULT_USER=guest - RABBITMQ_DEFAULT_PASS=guest - RABBITMQ_DEFAULT_VHOST=/ ports : - \"5672:5672\" - \"15672:15672\" volumes : - rabbitmq_data:/var/lib/rabbitmq - ./infrastructure/rabbitmq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:Z networks : - app-network restart : unless-stopped healthcheck : test : rabbitmq-diagnostics -q ping interval : 30s timeout : 10s retries : 5 # MinIO Object Storage minio : image : quay.io/minio/minio:latest container_name : ecommerce-minio command : server /data --console-address \":9001\" environment : - MINIO_ROOT_USER=${MINIO_ACCESS_KEY} - MINIO_ROOT_PASSWORD=${MINIO_SECRET_KEY} ports : - \"9000:9000\" - \"9001:9001\" volumes : - minio_data:/data networks : - app-network restart : unless-stopped healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:9000/minio/health/live\" ] interval : 30s timeout : 20s retries : 3 volumes : postgres_data : redis_data : rabbitmq_data : minio_data : user-service-nuget : product-service-nuget : order-service-nuget : payment-service-nuget : web-app-node-modules : networks : app-network : driver : bridge ipam : config : - subnet : 172.20.0.0/16","title":"Step 2: Main Compose Configuration"},{"location":"4_testing/using_composefilesforlocaldev/#step-3-development-override-configuration","text":"# podman-compose.override.yml version : '3.8' services : user-service : environment : - ASPNETCORE_ENVIRONMENT=Development - Logging__LogLevel__Default=Debug - Logging__LogLevel__Microsoft=Information - Development__EnableSensitiveDataLogging=true volumes : - ./api/UserService:/app:Z - user-service-nuget:/root/.nuget/packages command : > bash -c \" dotnet restore && dotnet watch run --urls http://+:8080 \" product-service : environment : - ASPNETCORE_ENVIRONMENT=Development - Logging__LogLevel__Default=Debug - Development__EnableSensitiveDataLogging=true volumes : - ./api/ProductService:/app:Z - product-service-nuget:/root/.nuget/packages command : > bash -c \" dotnet restore && dotnet watch run --urls http://+:8080 \" order-service : environment : - ASPNETCORE_ENVIRONMENT=Development - Logging__LogLevel__Default=Debug - Development__EnableSensitiveDataLogging=true volumes : - ./api/OrderService:/app:Z - order-service-nuget:/root/.nuget/packages command : > bash -c \" dotnet restore && dotnet watch run --urls http://+:8080 \" payment-service : environment : - ASPNETCORE_ENVIRONMENT=Development - Logging__LogLevel__Default=Debug - Development__EnableSensitiveDataLogging=true volumes : - ./api/PaymentService:/app:Z - payment-service-nuget:/root/.nuget/packages command : > bash -c \" dotnet restore && dotnet watch run --urls http://+:8080 \" web-app : environment : - NODE_ENV=development - FAST_REFRESH=true - CHOKIDAR_USEPOLLING=true - WATCHPACK_POLLING=true command : npm start stdin_open : true tty : true # Development tools pgadmin : image : dpage/pgadmin4:latest container_name : ecommerce-pgadmin environment : - PGADMIN_DEFAULT_EMAIL=admin@example.com - PGADMIN_DEFAULT_PASSWORD=admin ports : - \"5050:80\" volumes : - pgadmin_data:/var/lib/pgadmin networks : - app-network restart : unless-stopped redis-commander : image : rediscommander/redis-commander:latest container_name : ecommerce-redis-commander environment : - REDIS_HOSTS=local:redis:6379 - REDIS_PASSWORD=${REDIS_PASSWORD} ports : - \"8081:8081\" networks : - app-network restart : unless-stopped volumes : pgadmin_data :","title":"Step 3: Development Override Configuration"},{"location":"4_testing/using_composefilesforlocaldev/#step-4-environment-configuration","text":"# .env # Database Configuration DB_PASSWORD = dev_password_123 POSTGRES_DB = ecommerce_dev # Redis Configuration REDIS_PASSWORD = redis_dev_password # JWT Configuration JWT_SECRET = your_super_secret_jwt_key_for_development_only # MinIO Configuration MINIO_ACCESS_KEY = minioadmin MINIO_SECRET_KEY = minioadmin123 # Payment Gateway (Sandbox) PAYMENT_GATEWAY_API_KEY = sandbox_api_key PAYMENT_GATEWAY_SECRET_KEY = sandbox_secret_key # Development Settings ASPNETCORE_ENVIRONMENT = Development NODE_ENV = development","title":"Step 4: Environment Configuration"},{"location":"4_testing/using_composefilesforlocaldev/#step-5-development-Containerfiles","text":".NET Service Development Containerfile: # api/UserService/Containerfile.dev FROM registry.access.redhat.com/ubi8/dotnet-60 # Install development tools USER root RUN dnf update -y && \\ dnf install -y curl procps-ng && \\ dnf clean all # Create app user RUN groupadd -r appuser && useradd -r -g appuser appuser # Set working directory WORKDIR /app # Copy project files COPY --chown = appuser:appuser *.csproj ./ RUN dotnet restore # Copy source code COPY --chown = appuser:appuser . ./ # Switch to app user USER appuser # Expose port EXPOSE 8080 # Install dotnet tools for hot reload RUN dotnet tool install --global dotnet-ef RUN dotnet tool install --global dotnet-watch ENV PATH = \" $PATH :/home/appuser/.dotnet/tools\" # Default command for development (can be overridden) CMD [ \"dotnet\" , \"watch\" , \"run\" , \"--urls\" , \"http://+:8080\" ] React Development Containerfile: # web/Containerfile.dev FROM registry.access.redhat.com/ubi8/nodejs-16 # Install development tools USER root RUN dnf update -y && \\ dnf install -y git curl && \\ dnf clean all # Create app user RUN groupadd -r appuser && useradd -r -g appuser appuser # Set working directory WORKDIR /app # Copy package files COPY --chown = appuser:appuser package*.json ./ # Switch to app user USER appuser # Install dependencies RUN npm ci # Copy source code COPY --chown = appuser:appuser . ./ # Expose port EXPOSE 3000 # Set environment for development ENV NODE_ENV = development ENV CHOKIDAR_USEPOLLING = true ENV FAST_REFRESH = true # Start development server CMD [ \"npm\" , \"start\" ]","title":"Step 5: Development Containerfiles"},{"location":"4_testing/using_composefilesforlocaldev/#example-2-react-native-development-environment","text":"For React Native development, we need a specialized setup: # mobile-dev/compose.yml version : '3.8' services : # React Native Metro Bundler metro-bundler : build : context : . Containerfile : Containerfile.metro container_name : rn-metro-bundler environment : - NODE_ENV=development - REACT_NATIVE_PACKAGER_HOSTNAME=0.0.0.0 ports : - \"8081:8081\" # Metro bundler - \"9090:9090\" # Flipper volumes : - ./src:/app/src:Z - ./assets:/app/assets:Z - rn-node-modules:/app/node_modules networks : - mobile-network restart : unless-stopped # Android Development Environment android-dev : build : context : . Containerfile : Containerfile.android container_name : rn-android-dev environment : - DISPLAY=${DISPLAY} volumes : - /tmp/.X11-unix:/tmp/.X11-unix:Z - ./:/app:Z - android-sdk:/opt/android-sdk - gradle-cache:/root/.gradle networks : - mobile-network privileged : true restart : unless-stopped # API Mock Server for Development mock-api : image : registry.access.redhat.com/ubi8/nodejs-16 container_name : rn-mock-api working_dir : /app command : > bash -c \" npm install -g json-server && json-server --watch db.json --host 0.0.0.0 --port 3001 \" ports : - \"3001:3001\" volumes : - ./mock-data:/app:Z networks : - mobile-network restart : unless-stopped volumes : rn-node-modules : android-sdk : gradle-cache : networks : mobile-network : driver : bridge","title":"Example 2: React Native Development Environment"},{"location":"4_testing/using_composefilesforlocaldev/#example-3-database-management-and-seeding","text":"-- database/init-scripts/01-create-databases.sql -- Create separate databases for each service CREATE DATABASE userdb ; CREATE DATABASE productdb ; CREATE DATABASE orderdb ; CREATE DATABASE paymentdb ; -- Create service users CREATE USER userservice WITH ENCRYPTED PASSWORD 'dev_password_123' ; CREATE USER productservice WITH ENCRYPTED PASSWORD 'dev_password_123' ; CREATE USER orderservice WITH ENCRYPTED PASSWORD 'dev_password_123' ; CREATE USER paymentservice WITH ENCRYPTED PASSWORD 'dev_password_123' ; -- Grant permissions GRANT ALL PRIVILEGES ON DATABASE userdb TO userservice ; GRANT ALL PRIVILEGES ON DATABASE productdb TO productservice ; GRANT ALL PRIVILEGES ON DATABASE orderdb TO orderservice ; GRANT ALL PRIVILEGES ON DATABASE paymentdb TO paymentservice ; -- database/init-scripts/02-seed-data.sql \\ c productdb ; -- Sample product data for development INSERT INTO products ( id , name , description , price , stock_quantity , category_id , created_at ) VALUES ( '11111111-1111-1111-1111-111111111111' , 'Gaming Laptop' , 'High-performance gaming laptop' , 1299 . 99 , 10 , '22222222-2222-2222-2222-222222222222' , NOW ()), ( '33333333-3333-3333-3333-333333333333' , 'Wireless Mouse' , 'Ergonomic wireless mouse' , 29 . 99 , 50 , '44444444-4444-4444-4444-444444444444' , NOW ()), ( '55555555-5555-5555-5555-555555555555' , 'Mechanical Keyboard' , 'RGB mechanical keyboard' , 129 . 99 , 25 , '44444444-4444-4444-4444-444444444444' , NOW ()); \\ c userdb ; -- Sample user data for development INSERT INTO users ( id , email , first_name , last_name , password_hash , created_at ) VALUES ( 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa' , 'john.doe@example.com' , 'John' , 'Doe' , '$2a$11$example_hash' , NOW ()), ( 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb' , 'jane.smith@example.com' , 'Jane' , 'Smith' , '$2a$11$example_hash' , NOW ());","title":"Example 3: Database Management and Seeding"},{"location":"4_testing/using_composefilesforlocaldev/#common-pitfalls","text":"","title":"Common Pitfalls"},{"location":"4_testing/using_composefilesforlocaldev/#1-volume-mount-issues","text":"Problem : File permission errors or changes not reflecting in containers. Solution : Use proper SELinux contexts and understand rootless mapping: services : api : volumes : # Correct: Use :Z for SELinux relabeling - ./src:/app/src:Z # Incorrect: Missing SELinux context - ./src:/app/src","title":"1. Volume Mount Issues"},{"location":"4_testing/using_composefilesforlocaldev/#2-service-startup-dependencies","text":"Problem : Services starting before dependencies are ready. Solution : Use proper health checks and depends_on conditions: services : api : depends_on : database : condition : service_healthy redis : condition : service_healthy healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://localhost:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 40s","title":"2. Service Startup Dependencies"},{"location":"4_testing/using_composefilesforlocaldev/#3-network-connectivity-issues","text":"Problem : Services can't communicate or resolve each other's names. Solution : Use explicit networks and proper service naming: networks : app-network : driver : bridge ipam : config : - subnet : 172.20.0.0/16 services : api : networks : - app-network environment : - DATABASE_HOST=postgres # Use service name for internal communication","title":"3. Network Connectivity Issues"},{"location":"4_testing/using_composefilesforlocaldev/#4-resource-consumption","text":"Problem : Development environment consuming too many system resources. Solution : Set resource limits and use efficient base images: services : api : deploy : resources : limits : memory : 512M cpus : '0.5' reservations : memory : 256M cpus : '0.25'","title":"4. Resource Consumption"},{"location":"4_testing/using_composefilesforlocaldev/#best-practices","text":"","title":"Best Practices"},{"location":"4_testing/using_composefilesforlocaldev/#1-environment-configuration","text":"# Use environment-specific overrides # compose.yml - Base configuration # podman-compose.override.yml - Development overrides # podman-compose.prod.yml - Production configuration services : api : environment : - ASPNETCORE_ENVIRONMENT=${ENVIRONMENT:-Development} - DATABASE_URL=${DATABASE_URL} - REDIS_URL=${REDIS_URL}","title":"1. Environment Configuration"},{"location":"4_testing/using_composefilesforlocaldev/#2-development-scripts","text":"Create helper scripts for common development tasks: #!/bin/bash # scripts/dev-start.sh set -e echo \"\ud83d\ude80 Starting development environment...\" # Load environment variables if [ -f .env ] ; then export $( grep -v '^#' .env | xargs ) fi # Start services podman compose up -d postgres redis rabbitmq # Wait for databases to be ready echo \"\u23f3 Waiting for databases...\" sleep 10 # Run database migrations echo \"\ud83d\udd04 Running database migrations...\" podman compose exec user-service dotnet ef database update podman compose exec product-service dotnet ef database update podman compose exec order-service dotnet ef database update # Start application services echo \"\ud83d\udd27 Starting application services...\" podman compose up -d echo \"\u2705 Development environment is ready!\" echo \"\ud83c\udf10 Web app: http://localhost:3000\" echo \"\ud83d\udcca API docs: http://localhost/swagger\" echo \"\ud83d\uddc4\ufe0f Database admin: http://localhost:5050\" echo \"\ud83d\udce6 Redis admin: http://localhost:8081\" #!/bin/bash # scripts/dev-stop.sh echo \"\ud83d\uded1 Stopping development environment...\" podman compose down echo \"\ud83e\uddf9 Cleaning up...\" podman system prune -f --volumes echo \"\u2705 Development environment stopped!\"","title":"2. Development Scripts"},{"location":"4_testing/using_composefilesforlocaldev/#3-hot-reloading-configuration","text":"// Program.cs for .NET services if ( app . Environment . IsDevelopment ()) { app . UseDeveloperExceptionPage (); app . UseSwagger (); app . UseSwaggerUI (); // Enable detailed errors for development app . UseDeveloperExceptionPage (); // Enable CORS for local development app . UseCors ( builder => builder . AllowAnyOrigin () . AllowAnyMethod () . AllowAnyHeader ()); }","title":"3. Hot Reloading Configuration"},{"location":"4_testing/using_composefilesforlocaldev/#4-logging-and-debugging","text":"services : api : environment : - Logging__LogLevel__Default=Debug - Logging__LogLevel__Microsoft=Information - Logging__Console__IncludeScopes=true volumes : - ./logs:/app/logs:Z","title":"4. Logging and Debugging"},{"location":"4_testing/using_composefilesforlocaldev/#5-security-in-development","text":"# Use secrets for sensitive data even in development secrets : db_password : file : ./secrets/db_password.txt jwt_secret : file : ./secrets/jwt_secret.txt services : api : secrets : - db_password - jwt_secret environment : - ConnectionStrings__DefaultConnection=Host=postgres;Database=mydb;Username=user;Password_File=/run/secrets/db_password","title":"5. Security in Development"},{"location":"4_testing/using_composefilesforlocaldev/#tools-and-resources","text":"","title":"Tools and Resources"},{"location":"4_testing/using_composefilesforlocaldev/#development-tools","text":"Podman Desktop : GUI for container management Visual Studio Code : With Podman and development container extensions Postman : API testing and documentation pgAdmin : PostgreSQL administration Redis Commander : Redis data browser","title":"Development Tools"},{"location":"4_testing/using_composefilesforlocaldev/#monitoring-and-debugging","text":"# Add to podman-compose.override.yml for development monitoring services : prometheus : image : prom/prometheus:latest ports : - \"9090:9090\" volumes : - ./monitoring/prometheus-dev.yml:/etc/prometheus/prometheus.yml:Z grafana : image : grafana/grafana:latest ports : - \"3001:3000\" environment : - GF_SECURITY_ADMIN_PASSWORD=admin volumes : - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards:Z","title":"Monitoring and Debugging"},{"location":"4_testing/using_composefilesforlocaldev/#useful-commands","text":"# Start all services podman compose up -d # View logs for specific service podman compose logs -f user-service # Execute commands in running container podman compose exec user-service bash # Scale a service podman compose up -d --scale product-service = 2 # Rebuild and restart a service podman compose up -d --build user-service # Stop and remove all containers podman compose down # Remove volumes (careful with data loss) podman compose down -v # View resource usage podman stats # Clean up unused resources podman system prune -f","title":"Useful Commands"},{"location":"4_testing/using_composefilesforlocaldev/#hands-on-exercise","text":"","title":"Hands-on Exercise"},{"location":"4_testing/using_composefilesforlocaldev/#exercise-complete-microservices-development-environment","text":"Create a comprehensive development environment for a microservices-based application. Requirements: Application Services: Authentication service (.NET) Product catalog service (.NET) Order management service (.NET) Notification service (.NET) Web frontend (React) Mobile app development (React Native) Infrastructure Services: PostgreSQL database with multiple schemas Redis for caching and sessions RabbitMQ for event-driven communication MinIO for file storage Nginx as reverse proxy Development Features: Hot reloading for all services Database seeding with test data Automated database migrations Health checks for all services Centralized logging Development monitoring dashboard Developer Experience: One-command startup and shutdown Consistent environment across team Easy debugging and testing Documentation and helper scripts Deliverables: Complete podman compose  configuration Development Containerfiles for each service Database initialization and seeding scripts Development helper scripts Environment configuration management Documentation for onboarding new developers Performance optimization guide Evaluation Criteria: Environment startup time (< 2 minutes) Resource efficiency (< 4GB RAM usage) Hot reload functionality Service communication reliability Documentation quality Developer onboarding experience","title":"Exercise: Complete Microservices Development Environment"},{"location":"4_testing/using_composefilesforlocaldev/#summary","text":"Local development with podman compose  provides a powerful foundation for modern application development. Key takeaways include: Consistent Environments : podman compose  ensures all developers work with identical setups Production Parity : Local environments mirror production architecture and configuration Enhanced Security : Rootless containers provide better security isolation Developer Productivity : Hot reloading and automated setup reduce development friction Service Orchestration : Multi-service applications can be managed as cohesive units Resource Efficiency : Lightweight containers minimize system resource usage Debugging Capabilities : Individual service access and comprehensive logging aid troubleshooting By implementing these practices with .NET and React Native applications using podman compose  and Red Hat UBI images, development teams can achieve faster development cycles, improved code quality, and seamless collaboration. The investment in setting up comprehensive development environments pays dividends in reduced debugging time, consistent behavior across environments, and faster onboarding of new team members.","title":"Summary"},{"location":"ci_cd/cloud_native_ci_cd/","text":"","title":"Cloud-Native CI/CD"},{"location":"observability/dotnet_open_telementry/","text":"","title":"Dotnet open telementry"},{"location":"observability/dotnet_open_telemetry/","text":"","title":".NET OpenTelemetry"},{"location":"redhat_ecosystem/redhat_software_collections/","text":"","title":"Red Hat Software Collections"},{"location":"redhat_ecosystem/redhat_supply_chain_ubi/","text":"","title":"UBI and Supply Chain Security"}]}